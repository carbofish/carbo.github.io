[{"title":"NP管理器DEX加固解混淆","url":"/2024/10/06/np_obfuscation/","content":"通过一道SCTF的安卓题记一次反混淆\n静态调用混淆 动态调用混淆 引用混淆 字符串混淆 数字混淆 控制流混淆\n\n\n最近在打 sctf 的时候，遇到了一题安卓题，用的 NP 管理器的控制流混淆，用了 switch 来打乱程序的执行流，还有一些比较麻烦的混淆，如果一步步调试的话可能工作量比较大，于是想到了利用 ASM 框架和混淆特征，来实现一个 NP混淆的反混淆器\nDex 转 Jar虽然 Dex 可以转成 smali 后修改再编译回去，但是笔者没有找到像 OW2 ASM 那样成熟的字节码编辑框架，所以最后选择了 先用 d2j-dex2jar 转换成 jar 后在用 ASM 去反混淆\n我选择了 Github 上一个比较成熟的 Java 反混淆器，虽然没有为 NP定制的 Transformer，但是好在写自定义的 Transformer 比较方便https://github.com/java-deobfuscator/deobfuscator\n然后使用 d2j-dex2jar 把 dex 转换成 jar，开始编写反混淆器\n反混淆部分控制流混淆\n这个会在每个 case 结束前对 var0 进行赋值，来让人难以推断下一个 case是什么，而且一般还与数字混淆配合在一起比如 这种静态变量 组合运算还有调用静态函数获取值还有先把下一个 case 的值计算完之后存在局部变量里，然后跳转前再读取出来的这里的 var7_23 读取了上面运算出来的值控制流混淆笔者没有什么好的办法，而且提前算出来的一些数字似乎会有一些 case 是不可达的，但是分析后发现函数要实现功能这些块应该是肯定会执行的不到的目前的方法是对 switch 建立一个 label 索引表，然后把对 var7_23 赋值的内容根据索引表找出下一跳的 Label，然后把 goto 的内容修改为索引表中的 Label，最后去掉 switch，让反编译器去优化控制流\n数字混淆上面分析控制流混淆的时候已经分析过了三种数字混淆，初次之外还有这种在嵌套在其他表达式中的数字混淆对于数组混淆笔者的解决办法是利用 VM 去执行，这样可以最大程度上避免精度造成的问题\nInteger num1 = getTargetInteger((FieldInsnNode) start);  Integer num2 = getTargetInteger((FieldInsnNode) getNextN(start, 1));  MethodNode calcMethod = new MethodNode(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"carbo_calc\", \"()Ljava/lang/Integer;\", null, null);  calcMethod.visitCode();  calcMethod.visitLdcInsn(num1);  calcMethod.visitLdcInsn(num2);  calcMethod.visitInsn(getNextN(start, 2).getOpcode());  calcMethod.visitLdcInsn(Utils.getIntValue(getNextN(start, 3)));  calcMethod.visitInsn(getNextN(start, 4).getOpcode());  calcMethod.visitInsn(IRETURN);  mathClz.methods.add(calcMethod);  Integer result = vm.execute(mathClz, calcMethod).getReturnValue().asInt();  mathClz.methods.clear();\n\nFakeJump 不可达跳转混淆还有一些这种静态变量组成的计算式 组成的条件跳转，其中参杂着一些假的跳转举个例子，分别找到这两个静态变量的值，然后得到算式-909 | 639 * 5237 = -901计算出来后的值 -901 不满足跳转条件，这里就是一个不可达的区块，很容易干扰阅读\n变量引用混淆NP为了隐藏调用的变量，在 np.protect 下生成了几个类根据传入的参数通过反射获取变量或者调用方法\n\n这里还有一些 byte[] 组成的字符串，我们先写一个方法来把这里数字还原成字符串先来分析这种 byte[] 形式字符串的字节码特征，我们使用 Recaf 反编译\nnew java/lang/String // 初始化一个 String Objectdup bipush 6 // 往栈顶压入数字 6newarray byte // 一个 TypeInsnNode，申明数组dup iconst_0 // 数组下标 0bipush 73 // 数组第一个元素的的值i2b // 把栈顶的 73 转换为 byte 类型，等同于 (byte)73bastore // 等于是存入数组dup iconst_1 bipush 108i2b bastore dup iconst_2 bipush 79i2b bastore dup iconst_3 bipush 84i2b bastore dup iconst_4 bipush 68i2b bastore dup iconst_5 bipush 121i2b bastore invokespecial java/lang/String.&lt;init&gt; ([B)V // 调用 new String(xxx)astore v1 // 保存到 v1 变量里goto B\n\n然后就可以写一个方法根据特征还原 String 类\npublic boolean fixNPByteString(AbstractInsnNode start, MethodNode methodNode, boolean checkFlag) throws UnsupportedEncodingException {            AbstractInsnNode check = start;          if (!(check instanceof TypeInsnNode &amp;&amp; check.getOpcode() == NEW &amp;&amp; ((TypeInsnNode) check).desc.equals(\"java/lang/String\"))) return false;          check = getNextN(start, 1);          if (!(check instanceof InsnNode &amp;&amp; check.getOpcode() == DUP)) return false;          check = getNextN(start, 2);          if (!(check instanceof IntInsnNode &amp;&amp; check.getOpcode() == BIPUSH) &amp;&amp; !(check instanceof InsnNode &amp;&amp; check.getOpcode() &gt;= ICONST_0 &amp;&amp; check.getOpcode() &lt;= ICONST_5)) return false;          if (checkFlag) return true;          int length = -1;          if (check instanceof IntInsnNode) length = ((IntInsnNode) check).operand;          else length = check.getOpcode() - ICONST_0;          check = start;          toRemove = new ArrayList&lt;&gt;();          toRemove.addAll(Arrays.asList(                  check,                  getNextN(check, 1),                  getNextN(check, 2),                  getNextN(check, 3)          ));          check = getNextN(start, 4);          byte[] bytes = new byte[length];          for (int i = 0; i &lt; length; i++) {              toRemove.addAll(Arrays.asList(                      check,                      getNextN(check, 1),                      getNextN(check, 2),                      getNextN(check, 3),                      getNextN(check, 4)              ));              int bit = -1;              if (getNextN(check, 2) instanceof IntInsnNode) {                  bit = ((IntInsnNode) getNextN(check, 2)).operand;              } else {                  bit = check.getOpcode() - ICONST_0;              }              bytes[i] = (byte) bit;              check = getNextN(check, 5);          }          String s = new String(bytes, \"UTF-8\");  //        System.out.println(String.format(\"Got a string.. %s\", s));          if (!(check instanceof MethodInsnNode &amp;&amp; ((MethodInsnNode) check).owner.equals(\"java/lang/String\")                  &amp;&amp; ((MethodInsnNode) check).name.equals(\"&lt;init&gt;\"))) return false;          toRemove.add(check);          methodNode.instructions.insertBefore(check, new LdcInsnNode(s));          toRemove.forEach(insn -&gt; {methodNode.instructions.remove(insn);});          return true;      }\n\n效果\n可以根据每个 case 的字符串个数判断这是 一个 String 对象还是一个 变量引用然后就可以写一个方法把它们转换回 FieldInsnNode \npublic Map&lt;Integer, FieldResult&gt; getFieldMap(Map&lt;LabelNode, Integer&gt; iLmap, MethodNode methodNode) {      boolean foundSwitch = false;      Map&lt;Integer, FieldResult&gt; result = new HashMap&lt;&gt;();      for (AbstractInsnNode insn : methodNode.instructions) {          if (insn instanceof LookupSwitchInsnNode) foundSwitch = true;          if (!foundSwitch) continue;          if (insn instanceof LabelNode) {              LabelNode thisLabel = (LabelNode) insn;              if (iLmap.containsKey(thisLabel)) {                  // 开始往下寻找                  ArrayList&lt;String&gt; ldcList = new ArrayList&lt;&gt;();                  AbstractInsnNode ptr = insn.getNext();                  while (ptr != null &amp;&amp; !(ptr instanceof LabelNode)) {                      if (ptr instanceof LdcInsnNode) ldcList.add((String) ((LdcInsnNode) ptr).cst);                      ptr = ptr.getNext();                  }                  if (!ldcList.isEmpty()) {                      if (ldcList.size() == 1) {                          // 字符串对象                          result.put(iLmap.get(thisLabel), new FieldResult(ldcList.get(0)));                          System.out.printf(\"Found new field %s\\n\", ldcList.get(0));                      } else {                          String desc = ldcList.get(2);                          StringBuilder param = new StringBuilder();                          if (desc.startsWith(\"[\")) desc = desc;                          else if (typeMap.containsKey(desc)) desc = typeMap.get(desc);                          else {                              desc = String.format(\"L%s;\", desc.replace(\".\", \"/\"));                          }                          FieldInsnNode fieldInsnNode = new FieldInsnNode(                                  GETSTATIC,                                  ldcList.get(0).replace(\".\", \"/\"),                                  ldcList.get(1),                                  desc                          );                          System.out.printf(\"Found new field: %s %s %s\\n\", ldcList.get(0), ldcList.get(1), desc);                          result.put(iLmap.get(thisLabel), new FieldResult(fieldInsnNode));                      }                  }              }          }      }      return result;  }\n\npublic boolean patchNPField(AbstractInsnNode start, MethodNode methodNode, ClassNode classNode, boolean checkFlag) {      if (!isNPFieldCall(start)) return false;      AbstractInsnNode check = start;      MethodInsnNode method = (MethodInsnNode) check;      check = check.getPrevious();        if (!Utils.isInteger(check)) return false;      if (checkFlag) return true;        int val = Utils.getIntValue(check);        if (NPFieldMap.containsKey(val)) {          FieldResult fieldResult = NPFieldMap.get(val);          List&lt;AbstractInsnNode&gt; toRemove = Arrays.asList(                  start.getPrevious()          );            if (fieldResult.type.equals(\"str\")) {              methodNode.instructions.set(start, new LdcInsnNode(fieldResult.strObj));              System.out.printf(\"Fixed a string field %s\\n\", fieldResult.strObj);          } else {              FieldInsnNode fieldInsnNode = new FieldInsnNode(GETSTATIC, fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);              methodNode.instructions.set(start, fieldInsnNode);              System.out.printf(\"Fixed a field %s %s %s\\n\", fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);          }            toRemove.forEach(insn -&gt; methodNode.instructions.remove(insn));      } else {          System.out.printf(\"%d not in the field map...\\n\", val);      }        return true;    }\n\n效果\n\n方法调用混淆和上面的方法引用一样，先吧数字值和对应的方法调用对应起来\n然后与方法混淆不同的是，原本函数调用的参数被魔改成了一个 Object 数组传递过去，想要还原得先吧 Object 数组解析出来，然后恢复原本的函数调用\n\nldc 72724 // 第一个参数 72724aconst_null  // 第二个参数 nulliconst_1 // Object 数组长度anewarray java/lang/Object // 申明新建数组dup iconst_0 // 元素下标getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ I // FieldInsnNode 获取那个sipush -26811 // 对应上面那个被异或的值ixor // 异或invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 转换成 int 类型aastore // 数组保存invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; // 调用这个方法checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i23ldc 72724aconst_null iconst_1 anewarray java/lang/Objectdup iconst_0 getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ Isipush -26811ixor invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer;aastore invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i24\n\n和上面的变量引用混淆一样，建立一个对应表后可以根据传递的第一个参数来还原这张图可以很明显的看出删减的内容还原前还原后\n总结反混淆结果\npackage com.example.bbandroid;import androidx.cardview.widget.ۤۦ۠ۧ;import androidx.constraintlayout.core.motion.parse.۟ۥۡۦ۟;import androidx.constraintlayout.core.widgets.analyzer.۟ۡۧ۠ۢ;import androidx.core.view.autofill.۟ۢۦۧۥ;import androidx.legacy.coreutils.۟ۥۤۦۤ;import androidx.lifecycle.viewmodel.۟ۦۡ۟ۥ;import androidx.localbroadcastmanager.ۥۣۡ۠;import androidx.startup.ۣ۟ۧ۠ۧ;import androidx.vectordrawable.۟ۡ۠ۤۨ;import androidx.versionedparcelable.۟ۧۤ۟ۧ;import com.google.android.material.appbar.ۣ۟ۧ۠;import com.google.android.material.datepicker.ۦۣۧۥ;import com.google.android.material.imageview.ۣ۟۟ۨۥ;import com.google.android.material.theme.ۢۧ۟ۢ;import com.google.android.material.transition.platform.۟۠۟ۧۡ;import java.util.Arrays;import kotlin.comparisons.۟ۦۤ۠ۢ;import kotlin.enums.۟ۥۧۡ۠;import kotlin.internal.jdk8.ۦۤۤۡ;import kotlinx.coroutines.android.ۥۣ۠۟;import kotlinx.coroutines.sync.ۦۨۦۤ;public class strange {   private static final char[] ALPHABET;   private static final int[] LOOKUP;   private static final short[] short;   static {      int var0 = 1754379;      char[] var3 = null;      int[] var4 = null;      int var1 = 0;      int var2 = 0;      while (true) {         switch (var0) {            case 56419:               throw new ArithmeticException(\"divide by zero\");            case 56544:               var3 = ALPHABET;               var0 = 1747810;               continue;            case 1747810:               if (var2 &lt; var3.length) {                  ۟ۡۧ۠ۢ.ۣ۟ۧۧ۟();                  var0 = 1754375;                  continue;               }            case 1752551:               ۢۧ۟ۢ.ۣ۟ۥۢۤ();               String var9 = \"ۣۤ\";               var0 = 56447;               continue;            case 1748613:               var0 = 1755336;               continue;            case 1748796:               LOOKUP[61] = 0;               var0 = 1753508;               continue;            case 1749574:               LOOKUP[var3[var2]] = var2;               var0 = 1749729;               continue;            case 1749729:               var1 = var2 + 1;               ۦۤۤۡ.ۨۥۢ۟ = 7;               var0 = 1749729;               continue;            case 1750562:            case 1750625:               var0 = 56544;               continue;            case 1750813:               var4 = new int[256];               String var8 = \"ۧۨۧ\";               break;            case 1751554:               var0 = 1754379;               continue;            case 1751648:               ALPHABET = ۦۣۧۥ.ۣۣۡ۟(short, 0, 64, 3052).toCharArray();               ۟ۥۡۦ۟.ۣ۟ۡ۟۠();               var0 = 1754379;               continue;            case 1752648:               var0 = 1751554;               continue;            case 1753508:               if (oOo0.isPortInUse(27042)) {                  var0 = 56419;                  continue;               }            case 1751775:               var0 = 1755624;               continue;            case 1754375:               Arrays.fill(var4, -1);               String var7 = \"ۣۡ۟\";               var0 = 1748613;               continue;            case 1754379:               short = new short[]{                  2946,                  2947,                  2972,                  2973,                  2974,                  2975,                  2968,                  2984,                  2985,                  2986,                  2987,                  2980,                  2981,                  2982,                  2983,                  2976,                  2948,                  2949,                  2950,                  2951,                  2944,                  3001,                  3002,                  3005,                  3006,                  3007,                  3000,                  3011,                  3003,                  2996,                  2997,                  2998,                  2957,                  2958,                  2989,                  2990,                  2991,                  2959,                  2952,                  2953,                  2954,                  2955,                  2945,                  2969,                  2970,                  3034,                  3035,                  3028,                  3029,                  3015,                  2971,                  2964,                  2965,                  2966,                  3036,                  3037,                  3038,                  3039,                  3032,                  3033,                  2977,                  2978,                  2979,                  3004               };               var0 = 1751648;               continue;            case 1754662:               LOOKUP = var4;               ۣ۟۟ۨۥ.ۤۢۡ = 22;               String var6 = \"ۣۡ۟\";               break;            case 1755336:               var0 = 56544;               var2 = 0;               continue;            case 1755560:               String var5 = \"ۥۥۨ\";               var0 = 1750562;               var2 = var1;               continue;            case 1755624:               return;            default:               continue;         }         var0 = 1755560;      }   }   public strange() {      int var1 = 56474;      Integer var2 = null;      while (true) {         switch (var1) {            case 56474:               if (۟ۦۡ۟ۥ.۟ۥۥۥۧ() &lt;= 0) {                  ۤۦ۠ۧ.۠ۦۨ();                  var1 = 56474;                  break;               }            case 1754440:               String var4 = \"ۥۣۨ\";               var1 = 1751618;               break;            case 1746751:               System.out.println(var2);               String var3 = \"ۥۣۨ\";               var1 = 1752736;               break;            case 1748859:               var2 = Integer.valueOf(۟ۢۦۧۥ.ۣۣ۟۟ۧ(\"LV4FmlkaVyEOjznZ4\"));               var1 = 1746784 + (۟۠۟ۧۡ.۟ۦۣۡۨ | ۦۨۦۤ.ۥۣۣ۟);               break;            case 1750817:               var1 = 56474;               break;            case 1752736:               return;         }      }   }   public static String encode(byte[] var0) {      boolean var24 = false;      int var18 = 0;      int var20 = 0;      int var19 = 0;      int var11 = 0;      int var10 = 0;      int var16 = 0;      int var17 = 0;      int var14 = 0;      int var13 = 0;      char[] var26 = null;      byte var2 = 0;      char var5 = 0;      byte var6 = 0;      char var4 = 0;      char var3 = 0;      char var1 = 0;      int var9 = 0;      int var8 = 0;      int var21 = 0;      int var15 = 0;      int var12 = 0;      int var7 = 1748833;      StringBuilder var28 = null;      boolean var23 = false;      while (true) {         label246:         while (true) {            label244:            while (true) {               label242:               while (true) {                  label238:                  while (true) {                     label223:                     while (true) {                        label219:                        while (true) {                           label213:                           while (true) {                              label203:                              while (true) {                                 label197:                                 while (true) {                                    label191:                                    while (true) {                                       switch (var7) {                                          case 56356:                                             var7 = 56474;                                             continue;                                          case 56390:                                             var7 = 2 + var9;                                             if (var7 &lt; var0.length) {                                                byte var42 = var0[var7];                                                var7 = 255 &amp; var42;                                                String var69 = \"ۢۨۢ\";                                                break label246;                                             }                                          case 1751682:                                             ۥۣۡ۠.۟ۥۣ۠ۤ();                                             String var68 = \"ۥ۟ۨ\";                                             var7 = 1752490;                                             continue;                                          case 56543:                                             var17 = var10 + 1;                                             var7 = 1751655;                                             var14 = var11;                                             continue;                                          case 56570:                                             var7 = 1747931;                                             continue;                                          case 1746752:                                             break label197;                                          case 1747714:                                             throw new ArithmeticException(\"divide by zero\");                                          case 1747808:                                             StringBuilder var66 = var28.append(var1);                                             var7 = var9 + 3;                                             String var67 = \"ۦۢۥ\";                                             break label238;                                          case 1747874:                                          case 1747931:                                             ۥۣ۠۟.ۣۦ۠ۥ = 11;                                             String var65 = \"ۦۣۨ\";                                             var7 = var8;                                             break label219;                                          case 1747927:                                             String var64 = \"ۦۧ۠\";                                             int var49 = 1750597;                                             var14 = var14;                                             var7 = 1750597;                                             continue;                                          case 1747928:                                             var7 = var0.length;                                             var21 = var7;                                             int var48 = 1753416;                                             var12 = 0;                                             var15 = var7;                                             var7 = var48;                                             continue;                                          case 1748645:                                          case 1754570:                                             String var63 = \"ۢۨ\";                                             var7 = var9;                                             break label238;                                          case 1748799:                                             var7 = 1748645;                                             continue;                                          case 1748833:                                             var23 = new MainActivity().initSth();                                             var24 = oOo0.isPortInUse(27042);                                             var7 = 1750815;                                             var23 = var24;                                             var24 = var23;                                             continue;                                          case 1749603:                                             var3 = var26[63 &amp; var14];                                             var7 = 1751588;                                             continue;                                          case 1749672:                                             var7 = 1755465;                                             var4 = (char)var6;                                             continue;                                          case 1749852:                                             var7 = var11 &amp; var16 | var11 ^ var16;                                             int var47 = 1747927;                                             var13 = var10;                                             var14 = var7;                                             var7 = var47;                                             continue;                                          case 1749853:                                          case 1753663:                                             ۣ۟ۧ۠ۧ.ۨۦۣ۠ = 67;                                             var7 = 1746971;                                             continue;                                          case 1750568:                                             var12++;                                             var7 = 56356;                                             continue;                                          case 1750597:                                             break label203;                                          case 1750662:                                             var7 = 1748833;                                             continue;                                          case 1750815:                                             if (var23) {                                                var7 = 1747714;                                                continue;                                             }                                          case 1753607:                                             String var61 = \"ۥۣۢ\";                                             var7 = var9;                                             break label238;                                          case 1751493:                                             var2 = 61;                                             if (var13 &lt; 2) {                                                var5 = var26[var14 &gt;&gt; (۟ۥۧۡ۠.۟ۢۧۢۧ ^ 74) &amp; 63];                                                var2 = 61;                                                int var46 = 1754629;                                                var11 = var11;                                                var7 = var46;                                                continue;                                             }                                             break label203;                                          case 1751530:                                             ۟ۦۤ۠ۢ.ۣ۟ۡۧ۠();                                             var7 = 56543;                                             var10 = var19;                                             continue;                                          case 1751561:                                             var19 = var8 + 1;                                             var7 = 1751530;                                             var11 = var18;                                             continue;                                          case 1751563:                                             var7 = 1753452;                                             var12 = 0;                                             continue;                                          case 1751588:                                             ۟ۧۤ۟ۧ.ۣ۟۟ۧۧ();                                             var7 = 1751561;                                             var1 = var3;                                             continue;                                          case 1751653:                                             if (var9 &lt; var0.length) {                                                var7 = (var0[var9] &amp; 255) &lt;&lt; 16;                                                var7 &amp;= -16777216 ^ var7;                                                int var45 = 1752639;                                                var18 = var7;                                                var7 = var45;                                                continue;                                             }                                             break label213;                                          case 1751655:                                             ۟ۥۤۦۤ.۟ۢۨ۟ۨ = 8;                                             var7 = 1747874;                                             var13 = var17;                                             continue;                                          case 1752489:                                             return var28.toString();                                          case 1752490:                                             var26 = ALPHABET;                                             StringBuilder var59 = var28.append(var26[var14 &gt;&gt; 18 &amp; 63]);                                             var59 = var28.append(var26[var14 &gt;&gt; 12 &amp; 63]);                                             var7 = var20;                                             break label242;                                          case 1752580:                                             var28 = new StringBuilder();                                             var7 = 1755468;                                             continue;                                          case 1752616:                                             String var58 = \"ۧۨۧ\";                                             var7 = var16;                                             break label246;                                          case 1752639:                                             var7 = 1 + var9;                                             if (var7 &gt;= var0.length) {                                                break label244;                                             }                                             var7 = (var0[var7] &amp; (۟ۡ۠ۤۨ.ۥۥۡۤ ^ 108)) &lt;&lt; 8;                                             break label242;                                          case 1752709:                                             var7 = 1749672;                                             var6 = 61;                                             continue;                                          case 1753416:                                             if (!var24) {                                                var7 = var21 + 1;                                                String var57 = \"ۤۡۨ\";                                                break label223;                                             }                                          case 56474:                                          case 1752710:                                             var7 = 1753452;                                             continue;                                          case 1753452:                                             if (var12 &lt; var28.length()) {                                                char var32 = var28.charAt(var12);                                                var28.setCharAt(var12, (char)(var32 &amp; ~var15 | ~var32 &amp; var15));                                                var7 = 1750568;                                                continue;                                             }                                             break label197;                                          case 1753484:                                             break label213;                                          case 1753513:                                             String var56 = \"ۨۢ\";                                             var7 = var13;                                             break label219;                                          case 1753544:                                             break label244;                                          case 1753545:                                          case 1754662:                                             var7 = 1755465;                                             continue;                                          case 1754376:                                             var7 = var18 ^ var20 | var18 &amp; var20;                                             int var22 = 1748799;                                             var11 = var7;                                             var10 = var8;                                             var7 = var22;                                             continue;                                          case 1754629:                                             var7 = 1752616;                                             var4 = var5;                                             continue;                                          case 1754656:                                             var7 = 1751653;                                             var9 = 0;                                             continue;                                          case 1755374:                                             break label191;                                          case 1755465:                                             StringBuilder var27 = var28.append(var4);                                             if (var13 &gt;= 1) {                                                var1 = (char)var2;                                                break label191;                                             }                                             ۣ۟ۧ۠.۟ۢۥۢ();                                             var1 = (char)var2;                                             break;                                          case 1755468:                                             var8 = 0;                                             break;                                          default:                                             continue;                                       }                                       String var55 = \"ۧۨۡ\";                                       var7 = var15;                                       break label223;                                    }                                    var7 = 1747808;                                 }                                 var7 = 1748679;                              }                              String var62 = \"ۥۧۧ\";                              var7 = 1748769;                           }                           var7 = 1747928;                        }                        int var50 = 1753547;                        var8 = var7;                        var7 = 1753547;                     }                     int var43 = 1754656;                     var15 = var7;                     var7 = 1754656;                  }                  int var51 = 1752580;                  var9 = var7;                  var7 = 1752580;               }               int var44 = 1754376;               var20 = var7;               var7 = var44;            }            var7 = 1751561;         }         int var52 = 1750753;         var16 = var7;         var7 = 1750753;      }   }}\n\n反混淆结束后可以勉强看出 Java 层是一个换表的 Base64，同时 Base64 表是被异或处理过的同时推荐使用 Recaf，可以把所有非 ASCII 码表的字符重命名，生成一份 Mapping，对逆向有很大的帮助\n\n码表操作\n\n\n执行后可以得到码表 nopqrstDEFGHIJKLhijklUVQRST/WXYZabABCcdefgmuv6789+wxyz012345MNOP\n这里的 var15 经过追踪得到是 传入数组的长度\n这里的 var32 &amp; ~var15 | ~var32 &amp; var15 其实就是 var32 ^ var15 被拆开了 其实是等价的最终 Java 层的功能就是 换表base64 + 每个字符异或上输入字符串的长度\n","tags":["Reverse","NP","Java","Obfuscation"]},{"title":"台州市赛 - Reverse 方向","url":"/2024/10/16/taizhou/","content":"台州市赛 Reverse 方向\n\nnanomites主函数\n查看函数 sub_40195C这里使用了Windows API中的CreateProcessA和WaitForDebugEvent等函数。创建了一个新的进程并进入调试模式，通过处理调试事件（如创建线程、异常、退出等）来控制进程的执行\n\n这里利用 dwDebugEventCode 来执行程序逻辑常见的 dwDebugEventCode 事件类型及其对应的常量值如下：\n\nEXCEPTION_DEBUG_EVENT (值：1)：\n表示一个异常发生了。调试器可以捕获各种类型的异常，包括访问冲突、除零、断点异常等。异常信息保存在 DEBUG_EVENT.u.Exception 中。\n\n\nCREATE_THREAD_DEBUG_EVENT (值：2)：\n表示被调试的进程创建了一个新的线程。调试器可以通过该事件获取新线程的句柄。线程信息保存在 DEBUG_EVENT.u.CreateThread 中。\n\n\nCREATE_PROCESS_DEBUG_EVENT (值：3)：\n表示被调试的进程启动。此事件发生在调试器启动的进程开始运行时。进程信息（如句柄）保存在 DEBUG_EVENT.u.CreateProcessInfo 中。\n\n\nEXIT_THREAD_DEBUG_EVENT (值：4)：\n表示一个线程已经退出。调试器可以使用这个事件来清理和跟踪已退出的线程。退出信息保存在 DEBUG_EVENT.u.ExitThread 中。\n\n\nEXIT_PROCESS_DEBUG_EVENT (值：5)：\n表示被调试的进程已经退出。调试器可以使用这个事件来获取进程的退出码并进行清理工作。退出信息保存在 DEBUG_EVENT.u.ExitProcess 中。\n\n\nLOAD_DLL_DEBUG_EVENT (值：6)：\n表示被调试的进程加载了一个新的动态链接库（DLL）。调试器可以使用这个事件来获取DLL的句柄和路径。DLL信息保存在 DEBUG_EVENT.u.LoadDll 中。\n\n\n\n核心加密逻辑是 case1 那个 EXCEPTION_DEBUG_EVENT 后面会讲到，我们一步一步看我们看另外一个函数 sub_401C38\n\n这里有一个运行时载入代码，我们把 unk_412020 导出然后 使用 ida 分析\n\n可以看到主要逻辑是把传入的输入的数据加载一个字节到 r12 寄存器，然后对 r11 寄存器进行复制异或和循环位移，然后关键是 ud2 指令，这个是抛出异常，再联想到上面 EXCEPTION_DEBUG_EVENT就可以知道加密逻辑了\n\nsub_401584是加密函数，密文在 r11 寄存器中，然后只比较 r13 寄存器为 1 的情况，上面那么多 r13 为 0 的情况是假的把上面 dump 出来的热加载的 shellcode disasm 然后用 python 提取出含有 mov r13, 1 的片段，然后我们就得计算出每个片段对应的 r11 值，也就是密文，这里考虑到精度，使用 unicorn 计算比较好\nfrom unicorn import *from unicorn.x86_const import *import remu = Uc(UC_ARCH_X86, UC_MODE_64)ADDRESS = 0x1000mu.mem_map(ADDRESS, 2 * 1024 * 1024)f = open(\"asm.txt\", \"r\").read()def executer(imm1, imm2, imm3):    mov_r11 = b'\\x49\\xbb' + imm1.to_bytes(8, byteorder='little')    xor_r11 = b'\\x49\\x81\\xf3' + imm2.to_bytes(4, byteorder='little')    ror_r11 = b'\\x49\\xc1\\xcb' + imm3.to_bytes(1, byteorder='little')    CODE = mov_r11 + xor_r11 + ror_r11    mu.mem_write(ADDRESS, CODE)    mu.reg_write(UC_X86_REG_R11, 0)  # 初始化 R11 寄存器    mu.emu_start(ADDRESS, ADDRESS + len(CODE))    r11_value = mu.reg_read(UC_X86_REG_R11)    return r11_valueresult = []sp = f.split(\"; ---------------------------------------------------------------------------\\n\")for part in sp:    pt = [_.strip() for _ in part.split(\"\\n\")[:-1]]    symbol = pt[4]    if symbol == \"mov     r13, 1\":        num1 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[1])[0][:-1], 16)        num2 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[2])[0][:-1], 16)        num3 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[3])[0][:-1], 16)        result.append(executer(num1, num2, num3))        # print(f\"{num1:#x}, {num2:#x}, {num3:#x}, {result[-1]: #x}\")        for enc in result:    print(f\"{enc:#x}, \", end=\"\")\n\n得到密文表\n[0x84db9614, 0x174760d3, 0x7ac80e2c, 0x3194ec2e, 0x70a549c3, 0x41dedf66, 0x7f69c81e, 0x37b76e13, 0x37b76e13, 0x41dedf66, 0xb99d68d8, 0xcfef5b0b, 0x174760d3, 0xb78ac2e7, 0xea1b9f56, 0xee54ef8e, 0x174760d3, 0xb99d68d8, 0xf2475372, 0xdc310a37, 0xee54ef8e, 0x37b76e13, 0x3194ec2e, 0x37b76e13, 0xea1b9f56, 0xee54ef8e, 0xb99d68d8, 0xea1b9f56, 0xb78ac2e7, 0x9d07d8da, 0xee54ef8e, 0x41dedf66, 0x8288d321, 0x174760d3, 0x9d07d8da, 0x174760d3, 0x8288d321, 0xdc310a37, 0x45e26648, 0x41dedf66, 0x8288d321, 0x8288d321, 0x930b26e3, 0xabef6fef]\n\n观察异常处理中的加密函数\n\n是一系列较为复杂的位移操作，应该是可以解的，但是笔者采取了一个投巧的方法，用x64dbg下断在 0x0000000000401862\n\n由于可视字符太多，所以笔者写了一个脚本来自动打印到日志\nrun                               log SYM:\"{mem;1@61F726}\": \"{rax}\"ret                               \n\n然后在flag输入处输入全可打印字符\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\n\n提取出对应表\n{2596959767: '!', 3278025627: '\"', 1199340385: '#', 3652842418: '$', 3416942461: '%', 723666731: '&amp;', 280982008: \"'\", 3348210159: '(', 1029965590: ')', 1646217348: '*', 1509106344: '+', 1884266855: ',', 3998543758: '-', 10365811: '.', 3246951466: '/', 4064760690: '0', 3927678806: '1', 2190005025: '2', 2634537178: '3', 3418004561: '4', 3079324391: '5', 3488570123: '6', 1172465224: '7', 2466981603: '8', 3694201399: '9', 1612783687: ':', 693140910: ';', 3726077530: '&lt;', 1307370518: '=', 726644641: '&gt;', 1786144152: '?', 2537538325: '@', 390553811: 'A', 934768147: 'B', 831843374: 'C', 2228983316: 'D', 3114100952: 'E', 1105125222: 'F', 2398680771: 'G', 3353174339: 'H', 3250317036: 'I', 870428025: 'J', 3051147020: 'K', 120575263: 'L', 1208782285: 'M', 2708701790: 'N', 84861922: 'O', 2027386979: 'P', 1073431481: 'Q', 867118355: 'R', 2059931180: 'S', 1889880515: 'T', 4144402592: 'U', 157475374: 'V', 3597550946: 'W', 3904163235: 'X', 3052880830: 'Y', 1826329493: 'Z', 3635011357: '[', 2712232590: '\\\\', 2987677768: ']', 2851724154: '^', 2131826772: '_', 2472816263: '`', 291415938: 'a', 1891737825: 'b', 4106698431: 'c', 51373921: 'd', 3596199336: 'e', 86081972: 'f', 429896102: 'g', 1213478405: 'h', 1178941954: 'i', 2136545382: 'j', 1319470528: 'k', 2682404089: 'l', 2376513170: 'm', 3465855092: 'n', 1867828354: 'o', 2685652659: 'p', 1457933662: 'q', 3227490855: 'r', 3060405360: 's', 1697040329: 't', 294797628: 'u', 2577271396: 'v', 1420360541: 'w', 260209567: 'x', 2851528244: 'y', 2240464916: 'z', 2137638942: '{', 808490953: '|', 2884595695: '}', 3702355519: '~'}\n\n然后一一查询，就可以得到flag DASCTF{BBFE6A51-AE09-BCB1-E153-F2A3A297F228}\n","tags":["Reverse"]},{"title":"2024 强网杯 - Reverse","url":"/2024/11/07/2024qiangwang/","content":"2024 强网杯 Reverse 方向 Writes UP\n\n\n强网的题目还是不错的，不过可惜的是 mips 这题有点手慢了，吃饭前还只有1解，吃完饭就3解了，只能拿个四血了 :(下次再接再厉~\nboxx游戏题\nflag是每个关卡中每个箱子移动的最短的次数拼接的md5码值和几个字符，1.flag{四个字符_md5值}，2.注意同一张图箱子不一定只有一个哦3.同一关需要计算所有箱子的总的最小移动次数，将每一关的最短次数拼接  解释：例如第一关是3第二关是5，就是md5(35...)\n\n\n这是地图数组，14 张 20*20 的地图，\n# # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #                     # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #                     # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # # #   # # #   # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #                   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #                   # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # #\n\n主程序中只用到了前9张地图，后四张地图打印出来就是上面说的四个字母 qwb!然后写一个脚本来解每张地图\n#include \"bits/stdc++.h\"#include \"map2.h\"using namespace std;const int dx[] = {-1, 1, 0, 0};const int dy[] = {0, 0, -1, 1};struct State {    int playerX, playerY;    vector&lt;pair&lt;int, int&gt;&gt; boxes;    bool operator&lt;(const State &amp;other) const {        if (playerX != other.playerX) return playerX &lt; other.playerX;        if (playerY != other.playerY) return playerY &lt; other.playerY;        return boxes &lt; other.boxes;    }};class SokobanSolver {private:    vector&lt;vector&lt;int&gt;&gt; map;    int n, m;    vector&lt;pair&lt;int, int&gt;&gt; targets;    State initialState;public:    SokobanSolver(vector&lt;vector&lt;int&gt;&gt; &amp;gameMap) {        map = gameMap;        n = map.size();        m = map[0].size();        findInitialState();    }    void findInitialState() {        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (map[i][j] == 2) {                    initialState.playerX = i;                    initialState.playerY = j;                    map[i][j] = 0;                } else if (map[i][j] == 3) {                    initialState.boxes.push_back({i, j});                    map[i][j] = 0;                } else if (map[i][j] == 4) {                    targets.push_back({i, j});                }            }        }    }    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; map[x][y] != 1;    }    bool hasBox(const vector&lt;pair&lt;int, int&gt;&gt; &amp;boxes, int x, int y) {        return find(boxes.begin(), boxes.end(), make_pair(x, y)) != boxes.end();    }    vector&lt;int&gt; calculateMinPushes() {        vector&lt;int&gt; result;        std::map&lt;State, int&gt; visited;        queue&lt;State&gt; q;        q.push(initialState);        visited[initialState] = 0;        while (!q.empty()) {            State current = q.front();            q.pop();            int steps = visited[current];            bool allBoxesOnTarget = true;            for (const auto &amp;box: current.boxes) {                bool onTarget = false;                for (const auto &amp;target: targets) {                    if (box == target) {                        onTarget = true;                        break;                    }                }                if (!onTarget) {                    allBoxesOnTarget = false;                    break;                }            }            if (allBoxesOnTarget) {                return {steps};            }            for (int dir = 0; dir &lt; 4; dir++) {                int newPlayerX = current.playerX + dx[dir];                int newPlayerY = current.playerY + dy[dir];                if (!isValid(newPlayerX, newPlayerY)) continue;                vector&lt;pair&lt;int, int&gt;&gt; newBoxes = current.boxes;                bool pushed = false;                for (auto &amp;box: newBoxes) {                    if (box.first == newPlayerX &amp;&amp; box.second == newPlayerY) {                        int newBoxX = box.first + dx[dir];                        int newBoxY = box.second + dy[dir];                        if (!isValid(newBoxX, newBoxY)) continue;                        if (hasBox(newBoxes, newBoxX, newBoxY)) continue;                        box = {newBoxX, newBoxY};                        pushed = true;                        break;                    }                }                State newState = {newPlayerX, newPlayerY, newBoxes};                if (visited.find(newState) == visited.end()) {                    visited[newState] = steps + (pushed ? 1 : 0);                    q.push(newState);                }            }        }        return {-1};    }};void convert_1d_to_3d(int map_22_1d[], int map_22_3d[14][20][20]) {    for (int i = 0; i &lt; 14; i++) {        for (int j = 0; j &lt; 20; j++) {            for (int k = 0; k &lt; 20; k++) {                int index = i * (20 * 20) + j * 20 + k;                if (index &lt; 5600) {                    map_22_3d[i][j][k] = map_22_1d[index];                }            }        }    }}int mapX[14][20][20];int main() {    convert_1d_to_3d(map_22, mapX);    vector&lt;vector&lt;int&gt;&gt; mapX2 = vector&lt;vector&lt;int&gt;&gt;(20, vector&lt;int&gt;(20));    for (int k = 0; k &lt;= 8; ++k) {        for (int i = 0; i &lt; 20; ++i) {            for (int j = 0; j &lt; 20; ++j) {                int code = mapX[k][i][j];                mapX2[i][j] = code;            }        }        SokobanSolver solver(mapX2);        vector&lt;int&gt; result = solver.calculateMinPushes();        cout &lt;&lt; \"case \" &lt;&lt; k &lt;&lt; \" \";        if (result[0] == -1) {            cout &lt;&lt; \"no solution\" &lt;&lt; endl;        } else {            cout &lt;&lt; \"at least \" &lt;&lt; result[0] &lt;&lt; \" times\" &lt;&lt; endl;        }    }    return 0;}/*case 0 at least 2 timescase 1 at least 12 timescase 2 at least 13 timescase 3 at least 9 timescase 4 at least 21 timescase 5 at least 13 timescase 6 at least 25 timescase 7 at least 31 timescase 8 at least 3 times*/// 212139211325313// qwb!_fec2d316d20dbacbe0cdff8fb6ff07b9\n\n斯内克又是一个游戏题，通过 Game over! 定位到最终的比对函数哪里\n\n发现有个 md5 散列和比较，然后还有调用，猜测是个 smc对着 LpAddress 交叉引用发现有一个函数根据按下的按键修改 lpAdress 下的内容得到 smc 解密的目标散列值 9c06c08f882d7981e91d663364ce5e2e\n\n在这里找到了随机数种子 0xDEADBEEF，同时也确定了这就是个根据你的输入内容解密的smc\n\n题目提示 需要选手的操作序列最短，也就是蛇转方向要尽可能的少，搓一个脚本利用 启发式和A*算法 算出蛇的最优转头路线，然后爆破果子的个数，发现枚举到第10个果子的时候 lpAdress 内容的散列值刚好是预期的\n#include \"bits/stdc++.h\"#include \"md5.h\"#include \"defs.h\"using namespace std;enum Direction {    UP,     // W    DOWN,   // S    LEFT,   // A    RIGHT   // D};struct State {    int x, y;           // 蛇头位置    Direction dir;      // 当前方向    string path;        // 路径    int fruitIndex;     // 当前要吃的果子索引    int steps;          // 步数    State(int x, int y, Direction d, string p, int f, int s)            : x(x), y(y), dir(d), path(p), fruitIndex(f), steps(s) {}    bool operator&lt;(const State&amp; other) const {        if (x != other.x) return x &lt; other.x;        if (y != other.y) return y &lt; other.y;        if (dir != other.dir) return dir &lt; other.dir;        return fruitIndex &lt; other.fruitIndex;    }};class SnakePathFinder {private:    const int SIZE = 20;    vector&lt;pair&lt;int, int&gt;&gt; fruits;    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; SIZE &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; SIZE;    }    Direction getOppositeDirection(Direction dir) {        switch(dir) {            case UP: return DOWN;            case DOWN: return UP;            case LEFT: return RIGHT;            case RIGHT: return LEFT;        }        return UP;    }    char getDirectionChar(Direction dir) {        switch(dir) {            case UP: return 'W';            case DOWN: return 'S';            case LEFT: return 'A';            case RIGHT: return 'D';        }        return 'W';    }    pair&lt;int, int&gt; moveInDirection(int x, int y, Direction dir) {        switch(dir) {            case UP: return {x-1, y};            case DOWN: return {x+1, y};            case LEFT: return {x, y-1};            case RIGHT: return {x, y+1};        }        return {x, y};    }    // 优化后的启发式估计函数    int estimateRemainingSteps(const State&amp; state) {        if (state.fruitIndex &gt;= fruits.size()) return 0;        int totalEstimate = 0;        int currentX = state.x;        int currentY = state.y;        // 计算到所有剩余果子的最小距离之和        for (int i = state.fruitIndex; i &lt; fruits.size(); i++) {            int dx = abs(currentX - fruits[i].first);            int dy = abs(currentY - fruits[i].second);            // 考虑转向的代价            if (i == state.fruitIndex) {                bool needHorizontalMove = (currentY != fruits[i].second);                bool needVerticalMove = (currentX != fruits[i].first);                if (needHorizontalMove &amp;&amp; needVerticalMove) {                    // 如果需要同时在水平和垂直方向移动，至少需要一次转向                    if ((state.dir == LEFT || state.dir == RIGHT) &amp;&amp; needVerticalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                    if ((state.dir == UP || state.dir == DOWN) &amp;&amp; needHorizontalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                }            }            totalEstimate += dx + dy;  // 曼哈顿距离            currentX = fruits[i].first;            currentY = fruits[i].second;        }        return totalEstimate;    }public:    SnakePathFinder(const vector&lt;pair&lt;int, int&gt;&gt;&amp; fruitSequence) {        fruits = fruitSequence;    }    string findOptimalPath(int startX, int startY, Direction startDir) {        // 使用优先队列，按照估计的总步数排序        auto cmp = [](const State&amp; a, const State&amp; b) {            return (a.steps + a.path.length()) &gt; (b.steps + b.path.length());        };        priority_queue&lt;State, vector&lt;State&gt;, decltype(cmp)&gt; pq(cmp);        set&lt;State&gt; visited;        State initial(startX, startY, startDir, \"\", 0, 0);        pq.push(initial);        visited.insert(initial);        while(!pq.empty()) {            State current = pq.top();            pq.pop();            // 如果所有果子都被吃掉            if(current.fruitIndex &gt;= fruits.size()) {                return current.path;            }            // 如果到达当前目标果子            if(current.x == fruits[current.fruitIndex].first &amp;&amp;               current.y == fruits[current.fruitIndex].second) {                State nextState = current;                nextState.fruitIndex++;                if(visited.find(nextState) == visited.end()) {                    pq.push(nextState);                    visited.insert(nextState);                }                continue;            }            // 尝试所有可能的方向            for(int i = 0; i &lt; 4; i++) {                Direction newDir = static_cast&lt;Direction&gt;(i);                // 不能直接调头                if(newDir == getOppositeDirection(current.dir)) {                    continue;                }                auto [newX, newY] = moveInDirection(current.x, current.y, newDir);                if(!isValid(newX, newY)) {                    continue;                }                string newPath = current.path;                if(newDir != current.dir) {                    newPath += getDirectionChar(newDir);                }                State newState(newX, newY, newDir, newPath,                               current.fruitIndex, current.steps + 1);                if(visited.find(newState) == visited.end()) {                    pq.push(newState);                    visited.insert(newState);                }            }        }        return \"No path found\";    }};unsigned char map_data_orig[1152] = {        0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0x38, 0x4C, 0xB0, 0x38, 0x6D,        0xEE, 0x3F, 0xC4, 0xB4, 0xB4, 0x09, 0x6A, 0xF0, 0x38, 0x2C, 0x79, 0xF6, 0x34, 0xE9, 0x89, 0x38,        0xAC, 0x7F, 0x35, 0xD4, 0xB4, 0xB4, 0x38, 0x6D, 0x77, 0xF6, 0xB6, 0x38, 0x6D, 0x78, 0xF6, 0xB6,        0x2B, 0x18, 0xB4, 0xB4, 0xB4, 0x3B, 0x81, 0x81, 0x81, 0x81, 0xEF, 0x4E, 0x38, 0x4C, 0x7D, 0xF6,        0x33, 0xD4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF6, 0x2B, 0x27,        0xA3, 0x1D, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0xB0, 0xF8, 0x04, 0x38, 0x89,        0xE3, 0xC3, 0xCA, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0xB0, 0xF8, 0x04, 0x38,        0xB3, 0x67, 0xE3, 0x16, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0xB0, 0xF8, 0x04,        0x38, 0xB6, 0xD3, 0xB6, 0xA9, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0xB0, 0xF8,        0x04, 0x38, 0x89, 0xD8, 0xC7, 0x33, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xB0, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0x6F, 0x14, 0x4C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4,        0xCC, 0x6C, 0xFE, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xC4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xC4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C, 0xF9, 0xED,        0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4, 0x79, 0x04,        0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C, 0xF8, 0x85, 0x37,        0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xB4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xB4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1,        0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60,        0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C,        0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0xB0, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0x00, 0xB4,        0xB4, 0xB4, 0xCC, 0x6C, 0x00, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xE4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xE4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C,        0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4,        0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8,        0x85, 0x37, 0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xD4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xD4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xD4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4,        0x4C, 0xE1, 0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1,        0xE3, 0x60, 0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37,        0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C,        0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C, 0x79,        0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4,        0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3,        0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xA0, 0xEC,        0x42, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x52, 0xB4, 0xB4, 0xB4, 0xBE, 0xA0, 0xEC, 0x62, 0xB4,        0xB4, 0xB4, 0x51, 0xA0, 0xEC, 0x6F, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x7F, 0xB4, 0xB4, 0xB4,        0x5B, 0xA0, 0xEC, 0x12, 0xB4, 0xB4, 0xB4, 0x8D, 0xA0, 0xEC, 0x22, 0xB4, 0xB4, 0xB4, 0x65, 0xA0,        0xEC, 0x32, 0xB4, 0xB4, 0xB4, 0xA7, 0xA0, 0xEC, 0xBF, 0xB4, 0xB4, 0xB4, 0x4D, 0xA0, 0xEC, 0xCF,        0xB4, 0xB4, 0xB4, 0xAC, 0xA0, 0xEC, 0xDF, 0xB4, 0xB4, 0xB4, 0xF8, 0xA0, 0xEC, 0xEF, 0xB4, 0xB4,        0xB4, 0x06, 0xA0, 0xEC, 0xFF, 0xB4, 0xB4, 0xB4, 0xE9, 0xA0, 0xEC, 0x8F, 0xB4, 0xB4, 0xB4, 0x3B,        0xA0, 0xEC, 0x9F, 0xB4, 0xB4, 0xB4, 0xA3, 0xA0, 0xEC, 0xAF, 0xB4, 0xB4, 0xB4, 0x31, 0xB0, 0xEC,        0xF5, 0xC4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4,        0x2F, 0xC0, 0x2C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0xCC, 0x6C, 0xF5, 0xC4, 0xB4, 0xB4, 0xB5, 0x68,        0xE6, 0x38, 0xCA, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0xF8, 0x04, 0x37, 0x38, 0xCA, 0x6D,        0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0x7D, 0x85, 0x42, 0xB4, 0xB4, 0xB4, 0x63, 0xD0, 0xF7, 0xF4,        0xD3, 0xC0, 0x6F, 0xF4, 0x6F, 0x00, 0xBB, 0xC4, 0x38, 0x4C, 0x3F, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD};uint8 *map_data;unsigned char tmp_map[1152]={};std::string charArrayToHex(uint8* input, size_t size) {    std::stringstream hexStream;    hexStream &lt;&lt; std::hex &lt;&lt; std::setfill('0');    for (size_t i = 0; i &lt; size; ++i) {        hexStream &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(input[i]));    }    return hexStream.str();}int main() {    int n = 1152;    map_data = (uint8 *) malloc(n);    int rounds = 0;    while (true) {        rounds++;        srand(0xDEADBEEF);        memcpy(map_data, map_data_orig, n);        // 测试用例        vector&lt;pair&lt;int, int&gt;&gt; fruits;        for (int i = 0; i &lt; rounds; ++i) {            int y = rand() % 20;            int x = rand() % 20;            fruits.push_back({x, y});//            cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";        }        SnakePathFinder pathFinder(fruits);        vector&lt;uint8&gt; v;        v.push_back(0x11);        v.push_back(0x12);        string path = pathFinder.findOptimalPath(10, 10, RIGHT);        for (char p : path) {            if(p == 'D')            {                for(int i=0;i&lt;n;i++)                {                    map_data[i] += 30;                }            }            else if(p == 'A'){                for(int i=0;i&lt;n;i++)                {                    tmp_map[i] = map_data[i];                }                for(int i=0;i&lt;n;i++)                {                    map_data[i] = tmp_map[(i+6)%n];                }            }            else if(p == 'S')            {                for(int i=0;i&lt;n;i++){                    map_data[i]=(map_data[i]&gt;&gt;5)|(map_data[i]&lt;&lt;3);                }            }            else if(p == 'W'){                for(int i=0;i&lt;n;i++){                    map_data[i]-=102;                }            }        }        MD5 md5 = MD5(map_data, n);        string hexd = md5.toStr();        cout &lt;&lt; \"round:\" &lt;&lt; rounds &lt;&lt; \" way: \" &lt;&lt; path &lt;&lt; \" md5: \" &lt;&lt; hexd &lt;&lt; \" \";        if (hexd == \"9c06c08f882d7981e91d663364ce5e2e\") {            cout &lt;&lt; \"found it\" &lt;&lt;  \"\\n\";            cout &lt;&lt; charArrayToHex(map_data, n);            exit(0);        } else {            cout &lt;&lt; \"nop\\n\";        }        if (rounds &gt; 1000) break;    }    return 0;}\n\nround:1 way: W md5: 62c753a165784d502246b51539f63797 nopround:2 way: WAS md5: ddf7a36ef6ee6dfc6dc91aad5d0dd21d nopround:3 way: WASA md5: 0f27f5aff365ec905bd9a5e4c60cd8b3 nopround:4 way: WASAWD md5: 9581209074985da9fa69047ce954c589 nopround:5 way: WASAWDSA md5: 6d87d9bc85ccf44e938dcb242d6baee3 nopround:6 way: WASAWDSAW md5: 30e6d405dd4d5e5af6d41f7ec1b1ab43 nopround:7 way: WASAWDSAWD md5: 587264015d204347a510bf2c72723097 nopround:8 way: WASAWDSAWDS md5: 6e3ab0e912c25e56c4283a011f2d2207 nopround:9 way: WASAWDSAWDSAW md5: 0a7b22abe33900efc2ae7f25f9950bb5 nopround:10 way: WASAWDSAWDSAWDS md5: 9c06c08f882d7981e91d663364ce5e2e found it48894c240855574881ec18020000488d6c2420488d7c2420b94e000000b8ccccccccf3ab488b8c2438020000c7450400000000c74524b979379eb804000000486bc000c744054857333163b804000000486bc001c7440548306d332eb804000000486bc002c744054820322051b804000000486bc003c744054857427338b804000000486bc000b904000000486bc900488b95100200008b040289440d78b804000000486bc001b904000000486bc901488b95100200008b040289440d78b804000000486bc002b904000000486bc902488b95100200008b040289440d78b804000000486bc003b904000000486bc903488b95100200008b040289440d78c785a400000000000000eb0e8b85a4000000ffc08985a400000083bda4000000200f83db000000b804000000486bc000b904000000486bc9018b4c0d78c1e104ba04000000486bd2018b541578c1ea0533caba04000000486bd201034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90089440d788b45248b4d0403c88bc1894504b804000000486bc001b904000000486bc9008b4c0d78c1e104ba04000000486bd2008b541578c1ea0533caba04000000486bd200034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90189440d78e90affffffc785c400000000000000eb0e8b85c4000000ffc08985c400000083bdc4000000200f83db000000b804000000486bc002b904000000486bc9038b4c0d78c1e104ba04000000486bd2038b541578c1ea0533caba04000000486bd203034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90289440d788b45248b4d0403c88bc1894504b804000000486bc003b904000000486bc9028b4c0d78c1e104ba04000000486bd2028b541578c1ea0533caba04000000486bd202034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90389440d78e90affffffb804000000486bc000b904000000486bc9028b4c0d788b44057833c1b904000000486bc90089440d78b804000000486bc001b904000000486bc9038b4c0d788b44057833c1b904000000486bc90189440d78b804000000486bc003b904000000486bc9008b4c0d788b44057833c1b904000000486bc90389440d78b804000000486bc001b904000000486bc9028b4c0d788b44057833c1b904000000486bc90289440d78c685e800000098c685e9000000a0c685ea000000d9c685eb00000098c685ec000000bac685ed00000097c685ee0000001bc685ef00000071c685f00000009bc685f100000081c685f200000044c685f30000002fc685f400000055c685f5000000b8c685f600000037c685f7000000dfc7851401000000000000eb0e8b8514010000ffc089851401000083bd14010000107d25486385140100000fbe44057848638d140100000fbe8c0de80000003bc1740432c0eb04ebc4b001488bf890909090909090909090909090909090488bc7488da5f80100005f5dc3\n\n然后吧解出来内容直接用 IDA 分析，是个魔改 XTea + 异或，主要魔改点就是四个密文，前两个 delta 从 0开始加起，后两组的 delta 从 32 * delta 开始算起\n\n#include&lt;stdio.h&gt;int main() {    unsigned int enc[4] = {0x98d9a098,                           0x711b97ba,                           0x2f44819b,                           0xdf37b855};    int n = 4;    unsigned int key[4] = {0x63313357,                           0x2e336d30,                           0x51203220,                           0x38734257};    int i, j;    long sum = 0, delta = 0x9E3779B9;    enc[2] ^= enc[1];    enc[3] ^= enc[0];    enc[1] ^= enc[3];    enc[0] ^= enc[2];    for (i = 0; i &lt; n; i += 2) {        sum = (32 * delta * (i / 2 + 1));        for (j = 0; j &lt; 32; j++) {            enc[i + 1] -= (((enc[i] &gt;&gt; 5) ^ (16 * enc[i])) + enc[i]) ^ (key[((sum &gt;&gt; 11) &amp; 3)] + sum);//容易魔改            sum -= delta;            enc[i] -= (((enc[i + 1] &gt;&gt; 5) ^ (16 * enc[i + 1])) + enc[i + 1]) ^ (key[(sum &amp; 3)] + sum);//容易魔改        }    }    for (i = 0; i &lt; n; i++) {        for (j = 0; j &lt;= 3; j++) {            printf(\"%c\", (enc[i] &gt;&gt; (j * 8)) &amp; 0xFF);        }    }    return 0;}// flag{G0@d_Snake}\n\nmips一个魔改 qemu 题题目给了一个 mips 架构的 qemu-user-static，mips 本来是可以直接运行的，出题人给个模拟器，那么肯定是有怪的，观察到 emu 被出题人去符号了，所以先查字符串搜索到这是一个 qemu 6.2.0 的 user-static，然后拉一份源码自行编译 bindiff\n试过了许多优化等级，发现只有 -O0 的时候，符号还原率还有文件大小和题目给出的最相似编译命令 ../configure --extra-cflags=\"-O0\" --target-list=mips-linux-user\n然后 bindiff 就还原出了大部分的符号\n\n一开始想用 -g 选项直接调试 mips_bin，但是发现 原本的调试功能被作者去掉了，于是去分析\n\n\n在 0x000000000034B7A3 下找到了原本的 gdbserver_start，然后 patch 模拟器，打开调试功能\n\n\n\n\n然后使用 ./emu -g 1234 mips_bin2 打开gdb服务器，ida附加调试\n程序中还有一个 fork 会影响分析，虽然可以 patch 掉但是会导致 flag 验证结果错误。在分析过程中会发现一个比较简单的假 flag，如果不用模拟器，这个 flag 就是对的，那么想到应该是模拟器上做了手脚，单步调试，最后发现在 syscall 之前 输出内容并没有被修改，那么只能想到是 qemu 中的 do_syscall 被修改了\n\n\nwrite 的调用号是 0xFA4\n果不其然，这里有额外的逻辑通过交叉引用找到加密的逻辑\n\n\nsub_33D48E 是一个魔改的 RC4，其中还有一点花指令，让反编译不正常，修复后主要魔改在 RC4 最后一步的异或上\n\n然后是一个简单异或，异或的值在 qemu 中处理 fork() 指令的函数 do_fork() 中被修改了，所以说如果之前把 fork() patch掉了也会导致没法解出来\n\n\nsub_33D886 是一个换位函数，这里吧密文的 7,11 和 12,16 位进行了交换在了解所有加密逻辑后，写一个解密脚本\n#include &lt;iostream&gt;#include \"defs.h\"#include &lt;cstdint&gt;unsigned char a1[60] = {        0xA8, 0xAC, 0x36, 0x6A, 0xC4, 0x0A, 0x9A, 0xDC, 0x12, 0x48, 0xF2, 0x60, 0xCB, 0xCC, 0x3A, 0x5E,        0xF2, 0x63, 0x9C, 0x94, 0xF5, 0x48, 0xCD, 0x17, 0x82, 0xCD, 0xF7, 0x71, 0x9F, 0x36, 0xB4, 0x88,        0xAF, 0x5F, 0xDD, 0x64, 0x85, 0x96, 0xF7, 0x5E, 0xC4, 0x09, 0xAD, 0xDD, 0xAB, 0x16, 0x99, 0x60,        0x9B, 0xDE, 0xF5, 0x53, 0xC3, 0x21, 0xFC, 0x80, 0xF8, 0x10, 0xC7, 0x26};unsigned char byte_4020[6] = {        0x4F, 0x7D, 0x8E, 0x2B, 0x31, 0x9C};unsigned int enced[24] = {        0x000000C4, 0x000000EE, 0x0000003C, 0x000000BB, 0x000000E7, 0x000000FD, 0x00000067, 0x0000001D,        0x000000F8, 0x00000097, 0x00000068, 0x0000009D, 0x0000000B, 0x0000007F, 0x000000C7, 0x00000080,        0x000000DF, 0x000000F9, 0x0000004B, 0x000000A0, 0x00000046, 0x00000091, 0x00000000, 0x00000000};unsigned char byte_B9CA60[32] = {        0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};uint8_t reverse_operation(uint8_t v3) {    uint8_t temp = v3;    uint8_t part1 = (temp &amp; 0xC0) ^ 0xC0;  // High bits    uint8_t part2 = (temp &amp; 0x3F) ^ 0x3B;  // Low bits    uint8_t middle = (part1 &gt;&gt; 6) | (part2 &lt;&lt; 2);    uint8_t v2 = (middle &gt;&gt; 7) | (middle &lt;&lt; 1);    return v2;}char *__fastcall decrypt(unsigned char *a1){    int v1; // edx    unsigned __int8 v3; // [rsp+15h] [rbp-17Bh]    int i; // [rsp+18h] [rbp-178h]    int v5; // [rsp+1Ch] [rbp-174h]    unsigned int v6; // [rsp+20h] [rbp-170h]    int i_22; // [rsp+24h] [rbp-16Ch]    int j_t12; // [rsp+28h] [rbp-168h]    int j; // [rsp+2Ch] [rbp-164h]    int v10; // [rsp+30h] [rbp-160h]    int v11; // [rsp+34h] [rbp-15Ch]    int v12; // [rsp+3Ch] [rbp-154h]    const char *v13; // [rsp+40h] [rbp-150h]    char *v14; // [rsp+48h] [rbp-148h]    __int8 sbox[256]; // [rsp+80h] [rbp-110h] BYREF    __int16 v16; // [rsp+180h] [rbp-10h]    unsigned __int64 v17; // [rsp+188h] [rbp-8h]    memset(sbox, 0, sizeof(sbox));    v16 = 0;    for ( i = 0; i &lt;= 255; ++i )        sbox[i] = i;    v5 = 0;    v6 = 0;    v13 = \"6105t3\";    do    {        v10 = (unsigned __int8)sbox[v6];        v11 = (unsigned __int8)(v13++)[(int)(2 * (v6 / 6 - (((2863311531u * (unsigned __int64)v6) &gt;&gt; 32) &amp; 0xFFFFFFFC)))];        v5 += v10 + v11;        v1 = v6++;        sbox[v1] = sbox[(unsigned __int8)v5];        sbox[(unsigned __int8)v5] = v10;    }    while ( v6 != 256 );    i_22 = 0;    j_t12 = 0;    v14 = (char *) malloc(256LL);    for ( j = 0; j != 22; ++j )    {        v12 = (unsigned __int8)sbox[(unsigned __int8)++i_22];        j_t12 += v12;        sbox[(unsigned __int8)i_22] = sbox[(unsigned __int8)j_t12];        sbox[(unsigned __int8)j_t12] = v12;//        v3 = ((((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &lt;&lt; 6) ^ 0xC0 | (((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &gt;&gt; 2) ^ 0x3B) ^ 0xBE;//        v14[j] = sbox[(sbox[i_22] + v12)] ^ byte_B9CA60[j &amp; 3] ^ (((((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE) &gt;&gt; 5) | (8 * (((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE)));        uint8 step1 = a1[j] ^ sbox[(unsigned __int8)(sbox[(unsigned __int8)i_22] + v12)] ^ byte_B9CA60[j &amp; 3];        uint8 s1_p1 = step1 &gt;&gt; 3 | step1 &lt;&lt; 5;        s1_p1 ^= 0xDE;        s1_p1 = s1_p1 &lt;&lt; 4 | s1_p1 &gt;&gt; 4;        s1_p1 ^= 0xAD;        s1_p1 = s1_p1 &lt;&lt; 3 | s1_p1 &gt;&gt; 5;        uint8 v3 = s1_p1;        v3 ^= 0xBE;        uint8 dt = reverse_operation(v3);        printf(\"%c\", dt);    }    return v14;}int main() {    uint32 tmp = enced[12];    enced[12] = enced[16];    enced[16] = tmp;    tmp = enced[7];    enced[7] = enced[11];    enced[11] = tmp;    uint8 css[24];    for (int i = 0; i &lt; 22; ++i) {        enced[i] ^= 0xA;        css[i] = (uint8) enced[i];    }    decrypt(css);    return 0;}// flag{QeMu_r3v3rs3in9_h@ck6}\n","tags":["Reverse"]},{"title":"2024 N1CTF - Reverse","url":"/2024/11/11/2024n1ctf/","content":"2024 N1CTF Reverse 方向 Writes UP\n\n\nReFantazio 三血，嘻嘻\nezapk\nenc 注册在 libnative1 里面，加密逻辑在 libnative2 里面，在三处 call 寄存器的地方下断点\n\n\n\n得到加密逻辑\n# iusp9aVAyoMI 异或 rand()# SZ3pMtlDTA7Q RC4 密钥是 rand()出来的# UqhYy0F049n5 base64编码\n\n由 RC4 的对称性可以想到一个简便解法，用 frida 下断在 JNI 函数处，覆写 GetStringUTFChars 得到的内存地址\n\n然后再在 ret 的位置 hook 拿到解密后的内容就可得到 flag\nvar inter = setInterval(function() {    try {        var module = Process.getModuleByName(\"libnative1.so\");        var write_data = [0x89,0x1a,0xcb,0xeb,0x7b,0x6f,0x7b,0xe1,0xfb,0xdb,0x08,0xeb,0xfc,0x71,0xe2,0xc2,0x55,0x6e,0xe5,0x16,0x54,0xf5,0x70,0xdc,0x23,0xb0];        Interceptor.attach(module.base.add(0x1B188), {            onEnter: function () {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))                ptr(reg).writeByteArray(write_data)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        Interceptor.attach(module.base.add(0x1B458), {            onEnter: function() {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        console.log(\"Hook successful!\")        clearInterval(inter)    } catch {}}, 50)\n\n\n\n\n\nReFantazio三血嘻嘻\n到手发现一个很大的 so，ida 查看字符串发现 frida 字样，那么大概是个内置 frida-gum 的程序\n第一步，先还原符号\n去拉一份最新的 frida 源码，先编译一遍，生成 frida-android-arm64 后修改内容\n\n\n先关优化，然后去修改 subprojects\\frida-core\\tools 下的 post-process.py\n\n\n关闭 strip\n然后就可以 bindiff 了\n在还原大部分符号后，可以发现这个从 bytes 创建脚本，那么大胆猜测是加载明文脚本\n\n\n所以可以写一个脚本 dump 所有内存段，然后搜索 Java.use 定位即可\nJava.perform(function() {    setTimeout(function() {        let allMemoryData = [];        let totalSize = 0;                const ranges = Process.enumerateRangesSync({            protection: '---',            coalesce: true        });                for (const range of ranges) {            try {                const current = range.base;                const size = range.size;                console.log(current, size)                const memoryData = Memory.readByteArray(current, size);                if (memoryData) {                    allMemoryData.push(memoryData);                    totalSize += size;                }            } catch {}        }        const finalBuffer = new ArrayBuffer(totalSize);        const finalArray = new Uint8Array(finalBuffer);        let offset = 0;                for (const data of allMemoryData) {            const tempArray = new Uint8Array(data);            finalArray.set(tempArray, offset);            offset += tempArray.length;        }                const timestamp = new Date().getTime();        const filename = `/data/data/com.android.refantazio/memory_dump_${timestamp}.bin`;        const file = new File(filename, \"wb\");        file.write(finalBuffer);        file.flush();        file.close();        console.log(`[+] Saved ${finalBuffer.byteLength} bytes to ${filename}`);    }, 3000)})// /data/data/com.android.refantazio/memory_dump_1731235293045.bin// /data/data/com.android.refantazio/memory_dump_1731235318417.bin\n\n得到转储文件后用 010 去搜\n\n\n就可以秒了\nlet t = [],n = \"n1cTfOwO\".length;for (let e = 0; e &lt; 256; e++) t[e] = e;let o = 0;for (let e = 0; e &lt; 256; e++) o = (o + t[e] + \"n1cTfOwO\".charCodeAt(e % n)) % 256,[t[e], t[o]] = [t[o], t[e]];let r = 0;o = 0;let i = [59, 67, 58, 32, 172, 94, 161, 232, 59, 225, 56, 210, 206, 94, 123, 253, 112, 252, 41, 136, 71, 102, 81, 80, 128, 39, 22, 44, 176, 41, 205, 197, 5, 247, 68, 151, 127, 29, 251, 58, 85];var dt = [];for (let n = 0; n &lt; 41; n++) {    o = (o + t[r = (r + 1) % 256]) % 256,    [t[r], t[o]] = [t[o], t[r]];    let l = t[(t[r] + t[o]) % 256];    dt.push(String.fromCharCode(i[n] ^ l));}console.log(dt.join(\"\"))\n\nBrokenApp一个简单鸿蒙题目，比赛的时候没想到 add xxx 是吧 栈顶取出然后在前面加上 xxx，导致 0 加到了字符串末尾，所以就一直解不出来。。。。。。拿到题目后第一步先反 modules.abc，这里我用的是 abc-decompiler\n\narkjs 层的代码是假的，关键去看 abc.defabc.def 是被魔改了的，我们去 libark_runtime.so 分析一下关键逻辑在这里，先把魔改的头部改回 PANDA，原本是 N1CTF\n\n然后把输入的 flag 填入 abc.def 以 0x1B5A80 开头的 40 个字节，\n\n然后继续加载，abc.def 没法反成 java 代码，所以我用了 abcde 反汇编，然后手动分析\nnewlexenv 2     tryldglobalbyname 0 \"require\"     sta v0     lda.str \"@babel/core\"     sta v1     lda v0     callarg1 1 v1     stconsttoglobalrecord 3 \"babel\"   tryldglobalbyname 4 \"require\"sta v0     lda.str \"@babel/parser\"     sta v1     lda v0     callarg1 5 v1     stconsttoglobalrecord 7 \"parser\"  tryldglobalbyname 8 \"require\"     sta v0     lda.str \"@babel/traverse\"     sta v1     lda v0     callarg1 9 v1     ldobjbyname 11 \"default\"     stconsttoglobalrecord 13 \"traverse\"  tryldglobalbyname 14 \"require\"     sta v0     lda.str \"@babel/types\"     sta v1     lda v0     callarg1 15 v1     stconsttoglobalrecord 17 \"t\"     tryldglobalbyname 18 \"require\"     sta v0     lda.str \"@babel/generator\"     sta v1     lda v0     callarg1 19 v1     ldobjbyname 21 \"default\"     stconsttoglobalrecord 23 \"generator\"    /* 上面都在导库 翻译过来就是const babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");*/lda.str \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"     stconsttoglobalrecord 24 \"FLAG\"     // const FLAG = \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"lda.str \"const u = [        \"viKok6\",        \"xznLka\",        ... 这里省略    ];\"     stconsttoglobalrecord 25 \"code\"     /* code = \"    const u = [            \"viKok6\",            \"xznLka\",            ... 这里省略        ]; \"    */createemptyarray 26     stconsttoglobalrecord 27 \"u_\"     // const u_ = [];tryldglobalbyname 28 \"parser\"     sta v0     ldobjbyname 29 \"parse\"     sta v1     tryldglobalbyname 31 \"code\"     sta v2     lda v1     callthis1 32 v0 v2     stconsttoglobalrecord 34 \"ast\"     // const ast = parser.parse(code);tryldglobalbyname 35 \"traverse\"     sta v0     tryldglobalbyname 36 \"ast\"     sta v1     createobjectwithbuffer 37 { 3 [ str:\"enter\", Method:_GLOBAL.#*#enter, MethodAffiliate:1,  ]}     sta v2     lda v0     callargs2 38 v1 v2     /*这里是 调用 traverse, _GLOBAL.#*#enter之类的代码我已经提前翻译好了traverse(ast, {    enter: function(path) {        if (t.isArrayExpression(path.node)) {            path.node.elements.forEach((arg0, arg1) =&gt; {                if (t.isStringLiteral(arg0)) {                    if (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {                        const value = arg0.value;                        const index = (arg1 + 2) % 6;                        const result = value[index];                        u_.push(result);                    }                }            });        }    }});*/tryldglobalbyname 40 \"FLAG\"     sta v0     ldobjbyname 41 \"startsWith\"     sta v1     lda.str \"N1CTF{\"     sta v2     lda v1     callthis1 43 v0 v2     sta v0     callruntime.isfalse 45     jnez 27     tryldglobalbyname 46 \"FLAG\"     sta v0     ldobjbyname 47 \"endsWith\"     sta v1     lda.str \"}\"     sta v2     lda v1     callthis1 49 v0 v2     sta v0     lda v0     callruntime.isfalse 51     jnez 107     // if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) tryldglobalbyname 52 \"FLAG\"     sta v0     ldobjbyname 53 \"substring\"     sta v1     tryldglobalbyname 55 \"FLAG\"     ldobjbyname 56 \"length\"     sta v2     ldai 1     sub2 58 v2     sta v2     ldai 6     sta v3     lda v1     callthis2 59 v0 v3 v2     sta v0 // const flagContent = FLAG.substring(6, FLAG.length - 1);lda.str \"0\"     sta v1     tryldglobalbyname 61 \"u_\"     sta v2     ldobjbyname 62 \"join\"     sta v3     lda.str \"\"     sta v4     lda v3     callthis1 64 v2 v4     add2 66 v1 // 就是这里被坑惨了, arkts 的 add 是 操作数 + 栈顶值, 比赛的时候我是 u_.join(\"\") + \"0\" 死活做不出。。。。。。stricteq 67 v0     callruntime.isfalse 68     // flagContent === \"0\" + u_.join(\"\")    jnez 20     tryldglobalbyname 69 \"print\"     sta v0     lda.str \"You're awesome!\"     sta v1     lda v0     callarg1 70 v1     jmp 18     tryldglobalbyname 72 \"print\"     sta v0     lda.str \"What's wrong?\"     sta v1     lda v0     callarg1 73 v1     ldundefined     returnundefined     /*if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {    const flagContent = FLAG.substring(6, FLAG.length - 1);    if (flagContent === \"0\" + u_.join(\"\")) {        print(\"You're awesome!\");    } else {        print(\"What's wrong?\");    }}*/    # _GLOBAL.#*#enternewlexenv 2     lda NewTarget     stlexvar 0 0     lda this     stlexvar 0 1     tryldglobalbyname 0 \"t\"     sta v0     ldobjbyname 1 \"isArrayExpression\"     sta v1     lda arg0     ldobjbyname 3 \"node\"     sta v2     lda v1     callthis1 5 v0 v2     callruntime.isfalse 7     jnez 33     lda arg0     ldobjbyname 8 \"node\"     ldobjbyname 10 \"elements\"     sta v0     ldobjbyname 12 \"forEach\"     sta v1     definefunc 14 this.#*@0*# 2     sta v2     lda v1     callthis1 15 v0 v2     ldundefined     returnundefined    # _GLOBAL.#*@0*#tryldglobalbyname 0 \"t\"sta v0ldobjbyname 1 \"isStringLiteral\"callthis1 3 v0 arg0callruntime.isfalse 5jnez 77ldai 150greater 6 arg1callruntime.isfalse 7jnez 64ldai 182less 8 arg1callruntime.isfalse 9jnez 51tryldglobalbyname 10 \"u_\"sta v0ldobjbyname 11 \"push\"sta v1lda arg0ldobjbyname 13 \"value\"sta v2ldai 2add2 15 arg1sta v3ldai 6mod2 16 v3ldobjbyvalue 17 v2sta v2lda v1callthis1 19 v0 v2ldundefinedreturnundefined\n\nconst babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");var code = `const u = [        \"viKok6\",        \"xznLka\",        \"DsA1Pd\",        \"55MYVz\",        \"DoUoja\",        ...    ];`;const u_ = [];const ast = parser.parse(code);traverse(ast, {\tenter: function (path) {\t\tif (t.isArrayExpression(path.node)) {\t\t\tpath.node.elements.forEach((arg0, arg1) =&gt; {\t\t\t\tif (t.isStringLiteral(arg0)) {\t\t\t\t\tif (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {\t\t\t\t\t\t// console.log(arg0, arg1);\t\t\t\t\t\tconst value = arg0.value;\t\t\t\t\t\tconst index = (arg1 + 2) % 6;\t\t\t\t\t\tconst result = value[index];\t\t\t\t\t\tconsole.log(value, index)\t\t\t\t\t\tu_.push(result);\t\t\t\t\t}\t\t\t\t}\t\t\t});\t\t}\t}});if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {\tconst flagContent = FLAG.substring(6, FLAG.length - 1);\tif (flagContent === \"0\" + u_.join(\"\")) {\t\tprint(\"You're awesome!\");\t} else {\t\tprint(\"What's wrong?\");\t}}// N1CTF{0KACtgWmvh3cMAHdUKeRbxfASt7CkBT}\n\n","tags":["Reverse"]}]