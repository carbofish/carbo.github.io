[{"title":"NP管理器DEX加固解混淆","url":"/2024/10/06/np_obfuscation/","content":"通过一道SCTF的安卓题记一次反混淆\n静态调用混淆 动态调用混淆 引用混淆 字符串混淆 数字混淆 控制流混淆\n\n\n最近在打 sctf 的时候，遇到了一题安卓题，用的 NP 管理器的控制流混淆，用了 switch 来打乱程序的执行流，还有一些比较麻烦的混淆，如果一步步调试的话可能工作量比较大，于是想到了利用 ASM 框架和混淆特征，来实现一个 NP混淆的反混淆器\nDex 转 Jar虽然 Dex 可以转成 smali 后修改再编译回去，但是笔者没有找到像 OW2 ASM 那样成熟的字节码编辑框架，所以最后选择了 先用 d2j-dex2jar 转换成 jar 后在用 ASM 去反混淆\n我选择了 Github 上一个比较成熟的 Java 反混淆器，虽然没有为 NP定制的 Transformer，但是好在写自定义的 Transformer 比较方便https://github.com/java-deobfuscator/deobfuscator\n然后使用 d2j-dex2jar 把 dex 转换成 jar，开始编写反混淆器\n反混淆部分控制流混淆\n这个会在每个 case 结束前对 var0 进行赋值，来让人难以推断下一个 case是什么，而且一般还与数字混淆配合在一起比如 这种静态变量 组合运算还有调用静态函数获取值还有先把下一个 case 的值计算完之后存在局部变量里，然后跳转前再读取出来的这里的 var7_23 读取了上面运算出来的值控制流混淆笔者没有什么好的办法，而且提前算出来的一些数字似乎会有一些 case 是不可达的，但是分析后发现函数要实现功能这些块应该是肯定会执行的不到的目前的方法是对 switch 建立一个 label 索引表，然后把对 var7_23 赋值的内容根据索引表找出下一跳的 Label，然后把 goto 的内容修改为索引表中的 Label，最后去掉 switch，让反编译器去优化控制流\n数字混淆上面分析控制流混淆的时候已经分析过了三种数字混淆，初次之外还有这种在嵌套在其他表达式中的数字混淆对于数组混淆笔者的解决办法是利用 VM 去执行，这样可以最大程度上避免精度造成的问题\nInteger num1 = getTargetInteger((FieldInsnNode) start);  Integer num2 = getTargetInteger((FieldInsnNode) getNextN(start, 1));  MethodNode calcMethod = new MethodNode(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, \"carbo_calc\", \"()Ljava/lang/Integer;\", null, null);  calcMethod.visitCode();  calcMethod.visitLdcInsn(num1);  calcMethod.visitLdcInsn(num2);  calcMethod.visitInsn(getNextN(start, 2).getOpcode());  calcMethod.visitLdcInsn(Utils.getIntValue(getNextN(start, 3)));  calcMethod.visitInsn(getNextN(start, 4).getOpcode());  calcMethod.visitInsn(IRETURN);  mathClz.methods.add(calcMethod);  Integer result = vm.execute(mathClz, calcMethod).getReturnValue().asInt();  mathClz.methods.clear();\n\nFakeJump 不可达跳转混淆还有一些这种静态变量组成的计算式 组成的条件跳转，其中参杂着一些假的跳转举个例子，分别找到这两个静态变量的值，然后得到算式-909 | 639 * 5237 = -901计算出来后的值 -901 不满足跳转条件，这里就是一个不可达的区块，很容易干扰阅读\n变量引用混淆NP为了隐藏调用的变量，在 np.protect 下生成了几个类根据传入的参数通过反射获取变量或者调用方法\n\n这里还有一些 byte[] 组成的字符串，我们先写一个方法来把这里数字还原成字符串先来分析这种 byte[] 形式字符串的字节码特征，我们使用 Recaf 反编译\nnew java/lang/String // 初始化一个 String Objectdup bipush 6 // 往栈顶压入数字 6newarray byte // 一个 TypeInsnNode，申明数组dup iconst_0 // 数组下标 0bipush 73 // 数组第一个元素的的值i2b // 把栈顶的 73 转换为 byte 类型，等同于 (byte)73bastore // 等于是存入数组dup iconst_1 bipush 108i2b bastore dup iconst_2 bipush 79i2b bastore dup iconst_3 bipush 84i2b bastore dup iconst_4 bipush 68i2b bastore dup iconst_5 bipush 121i2b bastore invokespecial java/lang/String.&lt;init&gt; ([B)V // 调用 new String(xxx)astore v1 // 保存到 v1 变量里goto B\n\n然后就可以写一个方法根据特征还原 String 类\npublic boolean fixNPByteString(AbstractInsnNode start, MethodNode methodNode, boolean checkFlag) throws UnsupportedEncodingException {            AbstractInsnNode check = start;          if (!(check instanceof TypeInsnNode &amp;&amp; check.getOpcode() == NEW &amp;&amp; ((TypeInsnNode) check).desc.equals(\"java/lang/String\"))) return false;          check = getNextN(start, 1);          if (!(check instanceof InsnNode &amp;&amp; check.getOpcode() == DUP)) return false;          check = getNextN(start, 2);          if (!(check instanceof IntInsnNode &amp;&amp; check.getOpcode() == BIPUSH) &amp;&amp; !(check instanceof InsnNode &amp;&amp; check.getOpcode() &gt;= ICONST_0 &amp;&amp; check.getOpcode() &lt;= ICONST_5)) return false;          if (checkFlag) return true;          int length = -1;          if (check instanceof IntInsnNode) length = ((IntInsnNode) check).operand;          else length = check.getOpcode() - ICONST_0;          check = start;          toRemove = new ArrayList&lt;&gt;();          toRemove.addAll(Arrays.asList(                  check,                  getNextN(check, 1),                  getNextN(check, 2),                  getNextN(check, 3)          ));          check = getNextN(start, 4);          byte[] bytes = new byte[length];          for (int i = 0; i &lt; length; i++) {              toRemove.addAll(Arrays.asList(                      check,                      getNextN(check, 1),                      getNextN(check, 2),                      getNextN(check, 3),                      getNextN(check, 4)              ));              int bit = -1;              if (getNextN(check, 2) instanceof IntInsnNode) {                  bit = ((IntInsnNode) getNextN(check, 2)).operand;              } else {                  bit = check.getOpcode() - ICONST_0;              }              bytes[i] = (byte) bit;              check = getNextN(check, 5);          }          String s = new String(bytes, \"UTF-8\");  //        System.out.println(String.format(\"Got a string.. %s\", s));          if (!(check instanceof MethodInsnNode &amp;&amp; ((MethodInsnNode) check).owner.equals(\"java/lang/String\")                  &amp;&amp; ((MethodInsnNode) check).name.equals(\"&lt;init&gt;\"))) return false;          toRemove.add(check);          methodNode.instructions.insertBefore(check, new LdcInsnNode(s));          toRemove.forEach(insn -&gt; {methodNode.instructions.remove(insn);});          return true;      }\n\n效果\n可以根据每个 case 的字符串个数判断这是 一个 String 对象还是一个 变量引用然后就可以写一个方法把它们转换回 FieldInsnNode \npublic Map&lt;Integer, FieldResult&gt; getFieldMap(Map&lt;LabelNode, Integer&gt; iLmap, MethodNode methodNode) {      boolean foundSwitch = false;      Map&lt;Integer, FieldResult&gt; result = new HashMap&lt;&gt;();      for (AbstractInsnNode insn : methodNode.instructions) {          if (insn instanceof LookupSwitchInsnNode) foundSwitch = true;          if (!foundSwitch) continue;          if (insn instanceof LabelNode) {              LabelNode thisLabel = (LabelNode) insn;              if (iLmap.containsKey(thisLabel)) {                  // 开始往下寻找                  ArrayList&lt;String&gt; ldcList = new ArrayList&lt;&gt;();                  AbstractInsnNode ptr = insn.getNext();                  while (ptr != null &amp;&amp; !(ptr instanceof LabelNode)) {                      if (ptr instanceof LdcInsnNode) ldcList.add((String) ((LdcInsnNode) ptr).cst);                      ptr = ptr.getNext();                  }                  if (!ldcList.isEmpty()) {                      if (ldcList.size() == 1) {                          // 字符串对象                          result.put(iLmap.get(thisLabel), new FieldResult(ldcList.get(0)));                          System.out.printf(\"Found new field %s\\n\", ldcList.get(0));                      } else {                          String desc = ldcList.get(2);                          StringBuilder param = new StringBuilder();                          if (desc.startsWith(\"[\")) desc = desc;                          else if (typeMap.containsKey(desc)) desc = typeMap.get(desc);                          else {                              desc = String.format(\"L%s;\", desc.replace(\".\", \"/\"));                          }                          FieldInsnNode fieldInsnNode = new FieldInsnNode(                                  GETSTATIC,                                  ldcList.get(0).replace(\".\", \"/\"),                                  ldcList.get(1),                                  desc                          );                          System.out.printf(\"Found new field: %s %s %s\\n\", ldcList.get(0), ldcList.get(1), desc);                          result.put(iLmap.get(thisLabel), new FieldResult(fieldInsnNode));                      }                  }              }          }      }      return result;  }\n\npublic boolean patchNPField(AbstractInsnNode start, MethodNode methodNode, ClassNode classNode, boolean checkFlag) {      if (!isNPFieldCall(start)) return false;      AbstractInsnNode check = start;      MethodInsnNode method = (MethodInsnNode) check;      check = check.getPrevious();        if (!Utils.isInteger(check)) return false;      if (checkFlag) return true;        int val = Utils.getIntValue(check);        if (NPFieldMap.containsKey(val)) {          FieldResult fieldResult = NPFieldMap.get(val);          List&lt;AbstractInsnNode&gt; toRemove = Arrays.asList(                  start.getPrevious()          );            if (fieldResult.type.equals(\"str\")) {              methodNode.instructions.set(start, new LdcInsnNode(fieldResult.strObj));              System.out.printf(\"Fixed a string field %s\\n\", fieldResult.strObj);          } else {              FieldInsnNode fieldInsnNode = new FieldInsnNode(GETSTATIC, fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);              methodNode.instructions.set(start, fieldInsnNode);              System.out.printf(\"Fixed a field %s %s %s\\n\", fieldResult.fieldInsnNode.owner, fieldResult.fieldInsnNode.name, fieldResult.fieldInsnNode.desc);          }            toRemove.forEach(insn -&gt; methodNode.instructions.remove(insn));      } else {          System.out.printf(\"%d not in the field map...\\n\", val);      }        return true;    }\n\n效果\n\n方法调用混淆和上面的方法引用一样，先吧数字值和对应的方法调用对应起来\n然后与方法混淆不同的是，原本函数调用的参数被魔改成了一个 Object 数组传递过去，想要还原得先吧 Object 数组解析出来，然后恢复原本的函数调用\n\nldc 72724 // 第一个参数 72724aconst_null  // 第二个参数 nulliconst_1 // Object 数组长度anewarray java/lang/Object // 申明新建数组dup iconst_0 // 元素下标getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ I // FieldInsnNode 获取那个sipush -26811 // 对应上面那个被异或的值ixor // 异或invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer; // 转换成 int 类型aastore // 数组保存invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object; // 调用这个方法checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i23ldc 72724aconst_null iconst_1 anewarray java/lang/Objectdup iconst_0 getstatic kotlinx/coroutines/channels/ۨ۠ۤ۟.۟۠ۨۧۢ Isipush -26811ixor invokestatic java/lang/Integer.valueOf (I)Ljava/lang/Integer;aastore invokestatic np/protect/\\u06E5ۣۢۢ.n (ILjava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;checkcast java/lang/Booleaninvokevirtual java/lang/Boolean.booleanValue ()Zistore i24\n\n和上面的变量引用混淆一样，建立一个对应表后可以根据传递的第一个参数来还原这张图可以很明显的看出删减的内容还原前还原后\n总结反混淆结果\npackage com.example.bbandroid;import androidx.cardview.widget.ۤۦ۠ۧ;import androidx.constraintlayout.core.motion.parse.۟ۥۡۦ۟;import androidx.constraintlayout.core.widgets.analyzer.۟ۡۧ۠ۢ;import androidx.core.view.autofill.۟ۢۦۧۥ;import androidx.legacy.coreutils.۟ۥۤۦۤ;import androidx.lifecycle.viewmodel.۟ۦۡ۟ۥ;import androidx.localbroadcastmanager.ۥۣۡ۠;import androidx.startup.ۣ۟ۧ۠ۧ;import androidx.vectordrawable.۟ۡ۠ۤۨ;import androidx.versionedparcelable.۟ۧۤ۟ۧ;import com.google.android.material.appbar.ۣ۟ۧ۠;import com.google.android.material.datepicker.ۦۣۧۥ;import com.google.android.material.imageview.ۣ۟۟ۨۥ;import com.google.android.material.theme.ۢۧ۟ۢ;import com.google.android.material.transition.platform.۟۠۟ۧۡ;import java.util.Arrays;import kotlin.comparisons.۟ۦۤ۠ۢ;import kotlin.enums.۟ۥۧۡ۠;import kotlin.internal.jdk8.ۦۤۤۡ;import kotlinx.coroutines.android.ۥۣ۠۟;import kotlinx.coroutines.sync.ۦۨۦۤ;public class strange {   private static final char[] ALPHABET;   private static final int[] LOOKUP;   private static final short[] short;   static {      int var0 = 1754379;      char[] var3 = null;      int[] var4 = null;      int var1 = 0;      int var2 = 0;      while (true) {         switch (var0) {            case 56419:               throw new ArithmeticException(\"divide by zero\");            case 56544:               var3 = ALPHABET;               var0 = 1747810;               continue;            case 1747810:               if (var2 &lt; var3.length) {                  ۟ۡۧ۠ۢ.ۣ۟ۧۧ۟();                  var0 = 1754375;                  continue;               }            case 1752551:               ۢۧ۟ۢ.ۣ۟ۥۢۤ();               String var9 = \"ۣۤ\";               var0 = 56447;               continue;            case 1748613:               var0 = 1755336;               continue;            case 1748796:               LOOKUP[61] = 0;               var0 = 1753508;               continue;            case 1749574:               LOOKUP[var3[var2]] = var2;               var0 = 1749729;               continue;            case 1749729:               var1 = var2 + 1;               ۦۤۤۡ.ۨۥۢ۟ = 7;               var0 = 1749729;               continue;            case 1750562:            case 1750625:               var0 = 56544;               continue;            case 1750813:               var4 = new int[256];               String var8 = \"ۧۨۧ\";               break;            case 1751554:               var0 = 1754379;               continue;            case 1751648:               ALPHABET = ۦۣۧۥ.ۣۣۡ۟(short, 0, 64, 3052).toCharArray();               ۟ۥۡۦ۟.ۣ۟ۡ۟۠();               var0 = 1754379;               continue;            case 1752648:               var0 = 1751554;               continue;            case 1753508:               if (oOo0.isPortInUse(27042)) {                  var0 = 56419;                  continue;               }            case 1751775:               var0 = 1755624;               continue;            case 1754375:               Arrays.fill(var4, -1);               String var7 = \"ۣۡ۟\";               var0 = 1748613;               continue;            case 1754379:               short = new short[]{                  2946,                  2947,                  2972,                  2973,                  2974,                  2975,                  2968,                  2984,                  2985,                  2986,                  2987,                  2980,                  2981,                  2982,                  2983,                  2976,                  2948,                  2949,                  2950,                  2951,                  2944,                  3001,                  3002,                  3005,                  3006,                  3007,                  3000,                  3011,                  3003,                  2996,                  2997,                  2998,                  2957,                  2958,                  2989,                  2990,                  2991,                  2959,                  2952,                  2953,                  2954,                  2955,                  2945,                  2969,                  2970,                  3034,                  3035,                  3028,                  3029,                  3015,                  2971,                  2964,                  2965,                  2966,                  3036,                  3037,                  3038,                  3039,                  3032,                  3033,                  2977,                  2978,                  2979,                  3004               };               var0 = 1751648;               continue;            case 1754662:               LOOKUP = var4;               ۣ۟۟ۨۥ.ۤۢۡ = 22;               String var6 = \"ۣۡ۟\";               break;            case 1755336:               var0 = 56544;               var2 = 0;               continue;            case 1755560:               String var5 = \"ۥۥۨ\";               var0 = 1750562;               var2 = var1;               continue;            case 1755624:               return;            default:               continue;         }         var0 = 1755560;      }   }   public strange() {      int var1 = 56474;      Integer var2 = null;      while (true) {         switch (var1) {            case 56474:               if (۟ۦۡ۟ۥ.۟ۥۥۥۧ() &lt;= 0) {                  ۤۦ۠ۧ.۠ۦۨ();                  var1 = 56474;                  break;               }            case 1754440:               String var4 = \"ۥۣۨ\";               var1 = 1751618;               break;            case 1746751:               System.out.println(var2);               String var3 = \"ۥۣۨ\";               var1 = 1752736;               break;            case 1748859:               var2 = Integer.valueOf(۟ۢۦۧۥ.ۣۣ۟۟ۧ(\"LV4FmlkaVyEOjznZ4\"));               var1 = 1746784 + (۟۠۟ۧۡ.۟ۦۣۡۨ | ۦۨۦۤ.ۥۣۣ۟);               break;            case 1750817:               var1 = 56474;               break;            case 1752736:               return;         }      }   }   public static String encode(byte[] var0) {      boolean var24 = false;      int var18 = 0;      int var20 = 0;      int var19 = 0;      int var11 = 0;      int var10 = 0;      int var16 = 0;      int var17 = 0;      int var14 = 0;      int var13 = 0;      char[] var26 = null;      byte var2 = 0;      char var5 = 0;      byte var6 = 0;      char var4 = 0;      char var3 = 0;      char var1 = 0;      int var9 = 0;      int var8 = 0;      int var21 = 0;      int var15 = 0;      int var12 = 0;      int var7 = 1748833;      StringBuilder var28 = null;      boolean var23 = false;      while (true) {         label246:         while (true) {            label244:            while (true) {               label242:               while (true) {                  label238:                  while (true) {                     label223:                     while (true) {                        label219:                        while (true) {                           label213:                           while (true) {                              label203:                              while (true) {                                 label197:                                 while (true) {                                    label191:                                    while (true) {                                       switch (var7) {                                          case 56356:                                             var7 = 56474;                                             continue;                                          case 56390:                                             var7 = 2 + var9;                                             if (var7 &lt; var0.length) {                                                byte var42 = var0[var7];                                                var7 = 255 &amp; var42;                                                String var69 = \"ۢۨۢ\";                                                break label246;                                             }                                          case 1751682:                                             ۥۣۡ۠.۟ۥۣ۠ۤ();                                             String var68 = \"ۥ۟ۨ\";                                             var7 = 1752490;                                             continue;                                          case 56543:                                             var17 = var10 + 1;                                             var7 = 1751655;                                             var14 = var11;                                             continue;                                          case 56570:                                             var7 = 1747931;                                             continue;                                          case 1746752:                                             break label197;                                          case 1747714:                                             throw new ArithmeticException(\"divide by zero\");                                          case 1747808:                                             StringBuilder var66 = var28.append(var1);                                             var7 = var9 + 3;                                             String var67 = \"ۦۢۥ\";                                             break label238;                                          case 1747874:                                          case 1747931:                                             ۥۣ۠۟.ۣۦ۠ۥ = 11;                                             String var65 = \"ۦۣۨ\";                                             var7 = var8;                                             break label219;                                          case 1747927:                                             String var64 = \"ۦۧ۠\";                                             int var49 = 1750597;                                             var14 = var14;                                             var7 = 1750597;                                             continue;                                          case 1747928:                                             var7 = var0.length;                                             var21 = var7;                                             int var48 = 1753416;                                             var12 = 0;                                             var15 = var7;                                             var7 = var48;                                             continue;                                          case 1748645:                                          case 1754570:                                             String var63 = \"ۢۨ\";                                             var7 = var9;                                             break label238;                                          case 1748799:                                             var7 = 1748645;                                             continue;                                          case 1748833:                                             var23 = new MainActivity().initSth();                                             var24 = oOo0.isPortInUse(27042);                                             var7 = 1750815;                                             var23 = var24;                                             var24 = var23;                                             continue;                                          case 1749603:                                             var3 = var26[63 &amp; var14];                                             var7 = 1751588;                                             continue;                                          case 1749672:                                             var7 = 1755465;                                             var4 = (char)var6;                                             continue;                                          case 1749852:                                             var7 = var11 &amp; var16 | var11 ^ var16;                                             int var47 = 1747927;                                             var13 = var10;                                             var14 = var7;                                             var7 = var47;                                             continue;                                          case 1749853:                                          case 1753663:                                             ۣ۟ۧ۠ۧ.ۨۦۣ۠ = 67;                                             var7 = 1746971;                                             continue;                                          case 1750568:                                             var12++;                                             var7 = 56356;                                             continue;                                          case 1750597:                                             break label203;                                          case 1750662:                                             var7 = 1748833;                                             continue;                                          case 1750815:                                             if (var23) {                                                var7 = 1747714;                                                continue;                                             }                                          case 1753607:                                             String var61 = \"ۥۣۢ\";                                             var7 = var9;                                             break label238;                                          case 1751493:                                             var2 = 61;                                             if (var13 &lt; 2) {                                                var5 = var26[var14 &gt;&gt; (۟ۥۧۡ۠.۟ۢۧۢۧ ^ 74) &amp; 63];                                                var2 = 61;                                                int var46 = 1754629;                                                var11 = var11;                                                var7 = var46;                                                continue;                                             }                                             break label203;                                          case 1751530:                                             ۟ۦۤ۠ۢ.ۣ۟ۡۧ۠();                                             var7 = 56543;                                             var10 = var19;                                             continue;                                          case 1751561:                                             var19 = var8 + 1;                                             var7 = 1751530;                                             var11 = var18;                                             continue;                                          case 1751563:                                             var7 = 1753452;                                             var12 = 0;                                             continue;                                          case 1751588:                                             ۟ۧۤ۟ۧ.ۣ۟۟ۧۧ();                                             var7 = 1751561;                                             var1 = var3;                                             continue;                                          case 1751653:                                             if (var9 &lt; var0.length) {                                                var7 = (var0[var9] &amp; 255) &lt;&lt; 16;                                                var7 &amp;= -16777216 ^ var7;                                                int var45 = 1752639;                                                var18 = var7;                                                var7 = var45;                                                continue;                                             }                                             break label213;                                          case 1751655:                                             ۟ۥۤۦۤ.۟ۢۨ۟ۨ = 8;                                             var7 = 1747874;                                             var13 = var17;                                             continue;                                          case 1752489:                                             return var28.toString();                                          case 1752490:                                             var26 = ALPHABET;                                             StringBuilder var59 = var28.append(var26[var14 &gt;&gt; 18 &amp; 63]);                                             var59 = var28.append(var26[var14 &gt;&gt; 12 &amp; 63]);                                             var7 = var20;                                             break label242;                                          case 1752580:                                             var28 = new StringBuilder();                                             var7 = 1755468;                                             continue;                                          case 1752616:                                             String var58 = \"ۧۨۧ\";                                             var7 = var16;                                             break label246;                                          case 1752639:                                             var7 = 1 + var9;                                             if (var7 &gt;= var0.length) {                                                break label244;                                             }                                             var7 = (var0[var7] &amp; (۟ۡ۠ۤۨ.ۥۥۡۤ ^ 108)) &lt;&lt; 8;                                             break label242;                                          case 1752709:                                             var7 = 1749672;                                             var6 = 61;                                             continue;                                          case 1753416:                                             if (!var24) {                                                var7 = var21 + 1;                                                String var57 = \"ۤۡۨ\";                                                break label223;                                             }                                          case 56474:                                          case 1752710:                                             var7 = 1753452;                                             continue;                                          case 1753452:                                             if (var12 &lt; var28.length()) {                                                char var32 = var28.charAt(var12);                                                var28.setCharAt(var12, (char)(var32 &amp; ~var15 | ~var32 &amp; var15));                                                var7 = 1750568;                                                continue;                                             }                                             break label197;                                          case 1753484:                                             break label213;                                          case 1753513:                                             String var56 = \"ۨۢ\";                                             var7 = var13;                                             break label219;                                          case 1753544:                                             break label244;                                          case 1753545:                                          case 1754662:                                             var7 = 1755465;                                             continue;                                          case 1754376:                                             var7 = var18 ^ var20 | var18 &amp; var20;                                             int var22 = 1748799;                                             var11 = var7;                                             var10 = var8;                                             var7 = var22;                                             continue;                                          case 1754629:                                             var7 = 1752616;                                             var4 = var5;                                             continue;                                          case 1754656:                                             var7 = 1751653;                                             var9 = 0;                                             continue;                                          case 1755374:                                             break label191;                                          case 1755465:                                             StringBuilder var27 = var28.append(var4);                                             if (var13 &gt;= 1) {                                                var1 = (char)var2;                                                break label191;                                             }                                             ۣ۟ۧ۠.۟ۢۥۢ();                                             var1 = (char)var2;                                             break;                                          case 1755468:                                             var8 = 0;                                             break;                                          default:                                             continue;                                       }                                       String var55 = \"ۧۨۡ\";                                       var7 = var15;                                       break label223;                                    }                                    var7 = 1747808;                                 }                                 var7 = 1748679;                              }                              String var62 = \"ۥۧۧ\";                              var7 = 1748769;                           }                           var7 = 1747928;                        }                        int var50 = 1753547;                        var8 = var7;                        var7 = 1753547;                     }                     int var43 = 1754656;                     var15 = var7;                     var7 = 1754656;                  }                  int var51 = 1752580;                  var9 = var7;                  var7 = 1752580;               }               int var44 = 1754376;               var20 = var7;               var7 = var44;            }            var7 = 1751561;         }         int var52 = 1750753;         var16 = var7;         var7 = 1750753;      }   }}\n\n反混淆结束后可以勉强看出 Java 层是一个换表的 Base64，同时 Base64 表是被异或处理过的同时推荐使用 Recaf，可以把所有非 ASCII 码表的字符重命名，生成一份 Mapping，对逆向有很大的帮助\n\n码表操作\n\n\n执行后可以得到码表 nopqrstDEFGHIJKLhijklUVQRST/WXYZabABCcdefgmuv6789+wxyz012345MNOP\n这里的 var15 经过追踪得到是 传入数组的长度\n这里的 var32 &amp; ~var15 | ~var32 &amp; var15 其实就是 var32 ^ var15 被拆开了 其实是等价的最终 Java 层的功能就是 换表base64 + 每个字符异或上输入字符串的长度\n","tags":["Reverse","NP","Java","Obfuscation"]},{"title":"台州市赛 - Reverse 方向","url":"/2024/10/16/taizhou/","content":"台州市赛 Reverse 方向\n\nnanomites主函数\n查看函数 sub_40195C这里使用了Windows API中的CreateProcessA和WaitForDebugEvent等函数。创建了一个新的进程并进入调试模式，通过处理调试事件（如创建线程、异常、退出等）来控制进程的执行\n\n这里利用 dwDebugEventCode 来执行程序逻辑常见的 dwDebugEventCode 事件类型及其对应的常量值如下：\n\nEXCEPTION_DEBUG_EVENT (值：1)：\n表示一个异常发生了。调试器可以捕获各种类型的异常，包括访问冲突、除零、断点异常等。异常信息保存在 DEBUG_EVENT.u.Exception 中。\n\n\nCREATE_THREAD_DEBUG_EVENT (值：2)：\n表示被调试的进程创建了一个新的线程。调试器可以通过该事件获取新线程的句柄。线程信息保存在 DEBUG_EVENT.u.CreateThread 中。\n\n\nCREATE_PROCESS_DEBUG_EVENT (值：3)：\n表示被调试的进程启动。此事件发生在调试器启动的进程开始运行时。进程信息（如句柄）保存在 DEBUG_EVENT.u.CreateProcessInfo 中。\n\n\nEXIT_THREAD_DEBUG_EVENT (值：4)：\n表示一个线程已经退出。调试器可以使用这个事件来清理和跟踪已退出的线程。退出信息保存在 DEBUG_EVENT.u.ExitThread 中。\n\n\nEXIT_PROCESS_DEBUG_EVENT (值：5)：\n表示被调试的进程已经退出。调试器可以使用这个事件来获取进程的退出码并进行清理工作。退出信息保存在 DEBUG_EVENT.u.ExitProcess 中。\n\n\nLOAD_DLL_DEBUG_EVENT (值：6)：\n表示被调试的进程加载了一个新的动态链接库（DLL）。调试器可以使用这个事件来获取DLL的句柄和路径。DLL信息保存在 DEBUG_EVENT.u.LoadDll 中。\n\n\n\n核心加密逻辑是 case1 那个 EXCEPTION_DEBUG_EVENT 后面会讲到，我们一步一步看我们看另外一个函数 sub_401C38\n\n这里有一个运行时载入代码，我们把 unk_412020 导出然后 使用 ida 分析\n\n可以看到主要逻辑是把传入的输入的数据加载一个字节到 r12 寄存器，然后对 r11 寄存器进行复制异或和循环位移，然后关键是 ud2 指令，这个是抛出异常，再联想到上面 EXCEPTION_DEBUG_EVENT就可以知道加密逻辑了\n\nsub_401584是加密函数，密文在 r11 寄存器中，然后只比较 r13 寄存器为 1 的情况，上面那么多 r13 为 0 的情况是假的把上面 dump 出来的热加载的 shellcode disasm 然后用 python 提取出含有 mov r13, 1 的片段，然后我们就得计算出每个片段对应的 r11 值，也就是密文，这里考虑到精度，使用 unicorn 计算比较好\nfrom unicorn import *from unicorn.x86_const import *import remu = Uc(UC_ARCH_X86, UC_MODE_64)ADDRESS = 0x1000mu.mem_map(ADDRESS, 2 * 1024 * 1024)f = open(\"asm.txt\", \"r\").read()def executer(imm1, imm2, imm3):    mov_r11 = b'\\x49\\xbb' + imm1.to_bytes(8, byteorder='little')    xor_r11 = b'\\x49\\x81\\xf3' + imm2.to_bytes(4, byteorder='little')    ror_r11 = b'\\x49\\xc1\\xcb' + imm3.to_bytes(1, byteorder='little')    CODE = mov_r11 + xor_r11 + ror_r11    mu.mem_write(ADDRESS, CODE)    mu.reg_write(UC_X86_REG_R11, 0)  # 初始化 R11 寄存器    mu.emu_start(ADDRESS, ADDRESS + len(CODE))    r11_value = mu.reg_read(UC_X86_REG_R11)    return r11_valueresult = []sp = f.split(\"; ---------------------------------------------------------------------------\\n\")for part in sp:    pt = [_.strip() for _ in part.split(\"\\n\")[:-1]]    symbol = pt[4]    if symbol == \"mov     r13, 1\":        num1 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[1])[0][:-1], 16)        num2 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[2])[0][:-1], 16)        num3 = int(\"0x\" + re.findall(r\"[\\dA-Z]+h\", pt[3])[0][:-1], 16)        result.append(executer(num1, num2, num3))        # print(f\"{num1:#x}, {num2:#x}, {num3:#x}, {result[-1]: #x}\")        for enc in result:    print(f\"{enc:#x}, \", end=\"\")\n\n得到密文表\n[0x84db9614, 0x174760d3, 0x7ac80e2c, 0x3194ec2e, 0x70a549c3, 0x41dedf66, 0x7f69c81e, 0x37b76e13, 0x37b76e13, 0x41dedf66, 0xb99d68d8, 0xcfef5b0b, 0x174760d3, 0xb78ac2e7, 0xea1b9f56, 0xee54ef8e, 0x174760d3, 0xb99d68d8, 0xf2475372, 0xdc310a37, 0xee54ef8e, 0x37b76e13, 0x3194ec2e, 0x37b76e13, 0xea1b9f56, 0xee54ef8e, 0xb99d68d8, 0xea1b9f56, 0xb78ac2e7, 0x9d07d8da, 0xee54ef8e, 0x41dedf66, 0x8288d321, 0x174760d3, 0x9d07d8da, 0x174760d3, 0x8288d321, 0xdc310a37, 0x45e26648, 0x41dedf66, 0x8288d321, 0x8288d321, 0x930b26e3, 0xabef6fef]\n\n观察异常处理中的加密函数\n\n是一系列较为复杂的位移操作，应该是可以解的，但是笔者采取了一个投巧的方法，用x64dbg下断在 0x0000000000401862\n\n由于可视字符太多，所以笔者写了一个脚本来自动打印到日志\nrun                               log SYM:\"{mem;1@61F726}\": \"{rax}\"ret                               \n\n然后在flag输入处输入全可打印字符\n0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\n\n提取出对应表\n{2596959767: '!', 3278025627: '\"', 1199340385: '#', 3652842418: '$', 3416942461: '%', 723666731: '&amp;', 280982008: \"'\", 3348210159: '(', 1029965590: ')', 1646217348: '*', 1509106344: '+', 1884266855: ',', 3998543758: '-', 10365811: '.', 3246951466: '/', 4064760690: '0', 3927678806: '1', 2190005025: '2', 2634537178: '3', 3418004561: '4', 3079324391: '5', 3488570123: '6', 1172465224: '7', 2466981603: '8', 3694201399: '9', 1612783687: ':', 693140910: ';', 3726077530: '&lt;', 1307370518: '=', 726644641: '&gt;', 1786144152: '?', 2537538325: '@', 390553811: 'A', 934768147: 'B', 831843374: 'C', 2228983316: 'D', 3114100952: 'E', 1105125222: 'F', 2398680771: 'G', 3353174339: 'H', 3250317036: 'I', 870428025: 'J', 3051147020: 'K', 120575263: 'L', 1208782285: 'M', 2708701790: 'N', 84861922: 'O', 2027386979: 'P', 1073431481: 'Q', 867118355: 'R', 2059931180: 'S', 1889880515: 'T', 4144402592: 'U', 157475374: 'V', 3597550946: 'W', 3904163235: 'X', 3052880830: 'Y', 1826329493: 'Z', 3635011357: '[', 2712232590: '\\\\', 2987677768: ']', 2851724154: '^', 2131826772: '_', 2472816263: '`', 291415938: 'a', 1891737825: 'b', 4106698431: 'c', 51373921: 'd', 3596199336: 'e', 86081972: 'f', 429896102: 'g', 1213478405: 'h', 1178941954: 'i', 2136545382: 'j', 1319470528: 'k', 2682404089: 'l', 2376513170: 'm', 3465855092: 'n', 1867828354: 'o', 2685652659: 'p', 1457933662: 'q', 3227490855: 'r', 3060405360: 's', 1697040329: 't', 294797628: 'u', 2577271396: 'v', 1420360541: 'w', 260209567: 'x', 2851528244: 'y', 2240464916: 'z', 2137638942: '{', 808490953: '|', 2884595695: '}', 3702355519: '~'}\n\n然后一一查询，就可以得到flag DASCTF{BBFE6A51-AE09-BCB1-E153-F2A3A297F228}\n","tags":["Reverse"]},{"title":"2024 强网杯 - Reverse","url":"/2024/11/07/2024qiangwang/","content":"2024 强网杯 Reverse 方向 Writes UP\n\n\n强网的题目还是不错的，不过可惜的是 mips 这题有点手慢了，吃饭前还只有1解，吃完饭就3解了，只能拿个四血了 :(下次再接再厉~\nboxx游戏题\nflag是每个关卡中每个箱子移动的最短的次数拼接的md5码值和几个字符，1.flag{四个字符_md5值}，2.注意同一张图箱子不一定只有一个哦3.同一关需要计算所有箱子的总的最小移动次数，将每一关的最短次数拼接  解释：例如第一关是3第二关是5，就是md5(35...)\n\n\n这是地图数组，14 张 20*20 的地图，\n# # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #                     # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #   # # # # # # # #   # # # # # # ## # #                     # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # #   # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## #   # # # #   # # # #   # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # # #   # # #   # # # # # # # ## # #   # #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # #   #   #   #   # # # # # # # # ## # # # #   # # #   # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #   # # # # # # # # # # # # # # # ## # #                   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #   # # # # # # #   # # # # # # # ## # #                   # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #   # # #   # # # # # # # ## # # # # # #           # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #   #   # # # # # # # # ## # # # # # # #       # # # # # # # # ## # # # # # # # # # # # # # # # # # # ## # # # # # # # # # # # # # # # # # # #\n\n主程序中只用到了前9张地图，后四张地图打印出来就是上面说的四个字母 qwb!然后写一个脚本来解每张地图\n#include \"bits/stdc++.h\"#include \"map2.h\"using namespace std;const int dx[] = {-1, 1, 0, 0};const int dy[] = {0, 0, -1, 1};struct State {    int playerX, playerY;    vector&lt;pair&lt;int, int&gt;&gt; boxes;    bool operator&lt;(const State &amp;other) const {        if (playerX != other.playerX) return playerX &lt; other.playerX;        if (playerY != other.playerY) return playerY &lt; other.playerY;        return boxes &lt; other.boxes;    }};class SokobanSolver {private:    vector&lt;vector&lt;int&gt;&gt; map;    int n, m;    vector&lt;pair&lt;int, int&gt;&gt; targets;    State initialState;public:    SokobanSolver(vector&lt;vector&lt;int&gt;&gt; &amp;gameMap) {        map = gameMap;        n = map.size();        m = map[0].size();        findInitialState();    }    void findInitialState() {        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (map[i][j] == 2) {                    initialState.playerX = i;                    initialState.playerY = j;                    map[i][j] = 0;                } else if (map[i][j] == 3) {                    initialState.boxes.push_back({i, j});                    map[i][j] = 0;                } else if (map[i][j] == 4) {                    targets.push_back({i, j});                }            }        }    }    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; map[x][y] != 1;    }    bool hasBox(const vector&lt;pair&lt;int, int&gt;&gt; &amp;boxes, int x, int y) {        return find(boxes.begin(), boxes.end(), make_pair(x, y)) != boxes.end();    }    vector&lt;int&gt; calculateMinPushes() {        vector&lt;int&gt; result;        std::map&lt;State, int&gt; visited;        queue&lt;State&gt; q;        q.push(initialState);        visited[initialState] = 0;        while (!q.empty()) {            State current = q.front();            q.pop();            int steps = visited[current];            bool allBoxesOnTarget = true;            for (const auto &amp;box: current.boxes) {                bool onTarget = false;                for (const auto &amp;target: targets) {                    if (box == target) {                        onTarget = true;                        break;                    }                }                if (!onTarget) {                    allBoxesOnTarget = false;                    break;                }            }            if (allBoxesOnTarget) {                return {steps};            }            for (int dir = 0; dir &lt; 4; dir++) {                int newPlayerX = current.playerX + dx[dir];                int newPlayerY = current.playerY + dy[dir];                if (!isValid(newPlayerX, newPlayerY)) continue;                vector&lt;pair&lt;int, int&gt;&gt; newBoxes = current.boxes;                bool pushed = false;                for (auto &amp;box: newBoxes) {                    if (box.first == newPlayerX &amp;&amp; box.second == newPlayerY) {                        int newBoxX = box.first + dx[dir];                        int newBoxY = box.second + dy[dir];                        if (!isValid(newBoxX, newBoxY)) continue;                        if (hasBox(newBoxes, newBoxX, newBoxY)) continue;                        box = {newBoxX, newBoxY};                        pushed = true;                        break;                    }                }                State newState = {newPlayerX, newPlayerY, newBoxes};                if (visited.find(newState) == visited.end()) {                    visited[newState] = steps + (pushed ? 1 : 0);                    q.push(newState);                }            }        }        return {-1};    }};void convert_1d_to_3d(int map_22_1d[], int map_22_3d[14][20][20]) {    for (int i = 0; i &lt; 14; i++) {        for (int j = 0; j &lt; 20; j++) {            for (int k = 0; k &lt; 20; k++) {                int index = i * (20 * 20) + j * 20 + k;                if (index &lt; 5600) {                    map_22_3d[i][j][k] = map_22_1d[index];                }            }        }    }}int mapX[14][20][20];int main() {    convert_1d_to_3d(map_22, mapX);    vector&lt;vector&lt;int&gt;&gt; mapX2 = vector&lt;vector&lt;int&gt;&gt;(20, vector&lt;int&gt;(20));    for (int k = 0; k &lt;= 8; ++k) {        for (int i = 0; i &lt; 20; ++i) {            for (int j = 0; j &lt; 20; ++j) {                int code = mapX[k][i][j];                mapX2[i][j] = code;            }        }        SokobanSolver solver(mapX2);        vector&lt;int&gt; result = solver.calculateMinPushes();        cout &lt;&lt; \"case \" &lt;&lt; k &lt;&lt; \" \";        if (result[0] == -1) {            cout &lt;&lt; \"no solution\" &lt;&lt; endl;        } else {            cout &lt;&lt; \"at least \" &lt;&lt; result[0] &lt;&lt; \" times\" &lt;&lt; endl;        }    }    return 0;}/*case 0 at least 2 timescase 1 at least 12 timescase 2 at least 13 timescase 3 at least 9 timescase 4 at least 21 timescase 5 at least 13 timescase 6 at least 25 timescase 7 at least 31 timescase 8 at least 3 times*/// 212139211325313// qwb!_fec2d316d20dbacbe0cdff8fb6ff07b9\n\n斯内克又是一个游戏题，通过 Game over! 定位到最终的比对函数哪里\n\n发现有个 md5 散列和比较，然后还有调用，猜测是个 smc对着 LpAddress 交叉引用发现有一个函数根据按下的按键修改 lpAdress 下的内容得到 smc 解密的目标散列值 9c06c08f882d7981e91d663364ce5e2e\n\n在这里找到了随机数种子 0xDEADBEEF，同时也确定了这就是个根据你的输入内容解密的smc\n\n题目提示 需要选手的操作序列最短，也就是蛇转方向要尽可能的少，搓一个脚本利用 启发式和A*算法 算出蛇的最优转头路线，然后爆破果子的个数，发现枚举到第10个果子的时候 lpAdress 内容的散列值刚好是预期的\n#include \"bits/stdc++.h\"#include \"md5.h\"#include \"defs.h\"using namespace std;enum Direction {    UP,     // W    DOWN,   // S    LEFT,   // A    RIGHT   // D};struct State {    int x, y;           // 蛇头位置    Direction dir;      // 当前方向    string path;        // 路径    int fruitIndex;     // 当前要吃的果子索引    int steps;          // 步数    State(int x, int y, Direction d, string p, int f, int s)            : x(x), y(y), dir(d), path(p), fruitIndex(f), steps(s) {}    bool operator&lt;(const State&amp; other) const {        if (x != other.x) return x &lt; other.x;        if (y != other.y) return y &lt; other.y;        if (dir != other.dir) return dir &lt; other.dir;        return fruitIndex &lt; other.fruitIndex;    }};class SnakePathFinder {private:    const int SIZE = 20;    vector&lt;pair&lt;int, int&gt;&gt; fruits;    bool isValid(int x, int y) {        return x &gt;= 0 &amp;&amp; x &lt; SIZE &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; SIZE;    }    Direction getOppositeDirection(Direction dir) {        switch(dir) {            case UP: return DOWN;            case DOWN: return UP;            case LEFT: return RIGHT;            case RIGHT: return LEFT;        }        return UP;    }    char getDirectionChar(Direction dir) {        switch(dir) {            case UP: return 'W';            case DOWN: return 'S';            case LEFT: return 'A';            case RIGHT: return 'D';        }        return 'W';    }    pair&lt;int, int&gt; moveInDirection(int x, int y, Direction dir) {        switch(dir) {            case UP: return {x-1, y};            case DOWN: return {x+1, y};            case LEFT: return {x, y-1};            case RIGHT: return {x, y+1};        }        return {x, y};    }    // 优化后的启发式估计函数    int estimateRemainingSteps(const State&amp; state) {        if (state.fruitIndex &gt;= fruits.size()) return 0;        int totalEstimate = 0;        int currentX = state.x;        int currentY = state.y;        // 计算到所有剩余果子的最小距离之和        for (int i = state.fruitIndex; i &lt; fruits.size(); i++) {            int dx = abs(currentX - fruits[i].first);            int dy = abs(currentY - fruits[i].second);            // 考虑转向的代价            if (i == state.fruitIndex) {                bool needHorizontalMove = (currentY != fruits[i].second);                bool needVerticalMove = (currentX != fruits[i].first);                if (needHorizontalMove &amp;&amp; needVerticalMove) {                    // 如果需要同时在水平和垂直方向移动，至少需要一次转向                    if ((state.dir == LEFT || state.dir == RIGHT) &amp;&amp; needVerticalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                    if ((state.dir == UP || state.dir == DOWN) &amp;&amp; needHorizontalMove) {                        totalEstimate += 1;  // 考虑转向的代价                    }                }            }            totalEstimate += dx + dy;  // 曼哈顿距离            currentX = fruits[i].first;            currentY = fruits[i].second;        }        return totalEstimate;    }public:    SnakePathFinder(const vector&lt;pair&lt;int, int&gt;&gt;&amp; fruitSequence) {        fruits = fruitSequence;    }    string findOptimalPath(int startX, int startY, Direction startDir) {        // 使用优先队列，按照估计的总步数排序        auto cmp = [](const State&amp; a, const State&amp; b) {            return (a.steps + a.path.length()) &gt; (b.steps + b.path.length());        };        priority_queue&lt;State, vector&lt;State&gt;, decltype(cmp)&gt; pq(cmp);        set&lt;State&gt; visited;        State initial(startX, startY, startDir, \"\", 0, 0);        pq.push(initial);        visited.insert(initial);        while(!pq.empty()) {            State current = pq.top();            pq.pop();            // 如果所有果子都被吃掉            if(current.fruitIndex &gt;= fruits.size()) {                return current.path;            }            // 如果到达当前目标果子            if(current.x == fruits[current.fruitIndex].first &amp;&amp;               current.y == fruits[current.fruitIndex].second) {                State nextState = current;                nextState.fruitIndex++;                if(visited.find(nextState) == visited.end()) {                    pq.push(nextState);                    visited.insert(nextState);                }                continue;            }            // 尝试所有可能的方向            for(int i = 0; i &lt; 4; i++) {                Direction newDir = static_cast&lt;Direction&gt;(i);                // 不能直接调头                if(newDir == getOppositeDirection(current.dir)) {                    continue;                }                auto [newX, newY] = moveInDirection(current.x, current.y, newDir);                if(!isValid(newX, newY)) {                    continue;                }                string newPath = current.path;                if(newDir != current.dir) {                    newPath += getDirectionChar(newDir);                }                State newState(newX, newY, newDir, newPath,                               current.fruitIndex, current.steps + 1);                if(visited.find(newState) == visited.end()) {                    pq.push(newState);                    visited.insert(newState);                }            }        }        return \"No path found\";    }};unsigned char map_data_orig[1152] = {        0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0x38, 0x4C, 0xB0, 0x38, 0x6D,        0xEE, 0x3F, 0xC4, 0xB4, 0xB4, 0x09, 0x6A, 0xF0, 0x38, 0x2C, 0x79, 0xF6, 0x34, 0xE9, 0x89, 0x38,        0xAC, 0x7F, 0x35, 0xD4, 0xB4, 0xB4, 0x38, 0x6D, 0x77, 0xF6, 0xB6, 0x38, 0x6D, 0x78, 0xF6, 0xB6,        0x2B, 0x18, 0xB4, 0xB4, 0xB4, 0x3B, 0x81, 0x81, 0x81, 0x81, 0xEF, 0x4E, 0x38, 0x4C, 0x7D, 0xF6,        0x33, 0xD4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB0, 0xE8, 0xF6, 0x2B, 0x27,        0xA3, 0x1D, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0xB0, 0xF8, 0x04, 0x38, 0x89,        0xE3, 0xC3, 0xCA, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0xB0, 0xF8, 0x04, 0x38,        0xB3, 0x67, 0xE3, 0x16, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0xB0, 0xF8, 0x04,        0x38, 0xB6, 0xD3, 0xB6, 0xA9, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0xB0, 0xF8,        0x04, 0x38, 0x89, 0xD8, 0xC7, 0x33, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x38, 0x4C, 0xED, 0xB5, 0xD4, 0xB4, 0xB4, 0x4C,        0xF4, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xB0, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0x6F, 0x14, 0x4C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0xFE, 0xB4, 0xB4, 0xB4,        0xCC, 0x6C, 0xFE, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xC4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xC4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C, 0xF9, 0xED,        0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4, 0x79, 0x04,        0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C, 0xF8, 0x85, 0x37,        0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B, 0xF4, 0xB4,        0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C,        0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1, 0xB4, 0x4C,        0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xB4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1,        0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60,        0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C,        0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0xB0, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4,        0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0x00, 0xB4, 0xB4, 0xB4, 0x2F, 0xC0, 0x2C, 0xEC, 0x00, 0xB4,        0xB4, 0xB4, 0xCC, 0x6C, 0x00, 0xB4, 0xB4, 0xB4, 0xB6, 0x24, 0xCC, 0x72, 0xB4, 0xB4, 0xB4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xD4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xE4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xE4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xCC, 0xE2, 0xE4, 0x4C, 0xE1, 0x4C,        0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1, 0xE3, 0x60, 0xE4,        0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8,        0x85, 0x37, 0x4C, 0xE8, 0xF6, 0x4C, 0x69, 0xF4, 0xE4, 0x40, 0x4C, 0xD0, 0x2C, 0xE8, 0xF4, 0x3B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xD4, 0x4C, 0x79, 0x85, 0x37, 0xD0, 0xD2, 0xF4, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xE1,        0xD4, 0x4C, 0xF9, 0x05, 0x37, 0xD0, 0x62, 0x04, 0xE3, 0x60, 0x5B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xE1, 0xD4, 0xE4, 0x79, 0x05, 0x37, 0x4C, 0xE9, 0xF4, 0xD0, 0x62, 0x64, 0xCC, 0xE2, 0xE4,        0x4C, 0xE1, 0x4C, 0xF9, 0xED, 0x38, 0xF8, 0x4C, 0xE8, 0xF4, 0xF8, 0xE4, 0xE0, 0xA8, 0x4C, 0xC1,        0xE3, 0x60, 0xE4, 0x79, 0x04, 0x37, 0x4C, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x52, 0x54, 0x2F, 0x2F, 0x2F, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38,        0x4A, 0xC0, 0xB4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37,        0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x2C,        0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0x50, 0xE4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B,        0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xC4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4,        0xB4, 0x38, 0x4A, 0xC0, 0xE4, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xB4, 0x4C, 0x79,        0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3, 0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50,        0xE4, 0x2C, 0xF8, 0x85, 0x37, 0x3B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0xC0, 0xC4, 0x2B, 0xF4,        0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x4C, 0x79, 0x85, 0x37, 0x4C, 0xF8, 0x04, 0x37, 0xE3,        0xD0, 0x2B, 0xF4, 0xB4, 0xB4, 0xB4, 0x38, 0x4A, 0x50, 0xD4, 0x2C, 0xF8, 0x85, 0x37, 0xA0, 0xEC,        0x42, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x52, 0xB4, 0xB4, 0xB4, 0xBE, 0xA0, 0xEC, 0x62, 0xB4,        0xB4, 0xB4, 0x51, 0xA0, 0xEC, 0x6F, 0xB4, 0xB4, 0xB4, 0x3D, 0xA0, 0xEC, 0x7F, 0xB4, 0xB4, 0xB4,        0x5B, 0xA0, 0xEC, 0x12, 0xB4, 0xB4, 0xB4, 0x8D, 0xA0, 0xEC, 0x22, 0xB4, 0xB4, 0xB4, 0x65, 0xA0,        0xEC, 0x32, 0xB4, 0xB4, 0xB4, 0xA7, 0xA0, 0xEC, 0xBF, 0xB4, 0xB4, 0xB4, 0x4D, 0xA0, 0xEC, 0xCF,        0xB4, 0xB4, 0xB4, 0xAC, 0xA0, 0xEC, 0xDF, 0xB4, 0xB4, 0xB4, 0xF8, 0xA0, 0xEC, 0xEF, 0xB4, 0xB4,        0xB4, 0x06, 0xA0, 0xEC, 0xFF, 0xB4, 0xB4, 0xB4, 0xE9, 0xA0, 0xEC, 0x8F, 0xB4, 0xB4, 0xB4, 0x3B,        0xA0, 0xEC, 0x9F, 0xB4, 0xB4, 0xB4, 0xA3, 0xA0, 0xEC, 0xAF, 0xB4, 0xB4, 0xB4, 0x31, 0xB0, 0xEC,        0xF5, 0xC4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0xB4, 0x6F, 0x14, 0x4C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4,        0x2F, 0xC0, 0x2C, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0xCC, 0x6C, 0xF5, 0xC4, 0xB4, 0xB4, 0xB5, 0x68,        0xE6, 0x38, 0xCA, 0xEC, 0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0xF8, 0x04, 0x37, 0x38, 0xCA, 0x6D,        0xF5, 0xC4, 0xB4, 0xB4, 0x24, 0x1B, 0x7D, 0x85, 0x42, 0xB4, 0xB4, 0xB4, 0x63, 0xD0, 0xF7, 0xF4,        0xD3, 0xC0, 0x6F, 0xF4, 0x6F, 0x00, 0xBB, 0xC4, 0x38, 0x4C, 0x3F, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD};uint8 *map_data;unsigned char tmp_map[1152]={};std::string charArrayToHex(uint8* input, size_t size) {    std::stringstream hexStream;    hexStream &lt;&lt; std::hex &lt;&lt; std::setfill('0');    for (size_t i = 0; i &lt; size; ++i) {        hexStream &lt;&lt; std::setw(2) &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(input[i]));    }    return hexStream.str();}int main() {    int n = 1152;    map_data = (uint8 *) malloc(n);    int rounds = 0;    while (true) {        rounds++;        srand(0xDEADBEEF);        memcpy(map_data, map_data_orig, n);        // 测试用例        vector&lt;pair&lt;int, int&gt;&gt; fruits;        for (int i = 0; i &lt; rounds; ++i) {            int y = rand() % 20;            int x = rand() % 20;            fruits.push_back({x, y});//            cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \"\\n\";        }        SnakePathFinder pathFinder(fruits);        vector&lt;uint8&gt; v;        v.push_back(0x11);        v.push_back(0x12);        string path = pathFinder.findOptimalPath(10, 10, RIGHT);        for (char p : path) {            if(p == 'D')            {                for(int i=0;i&lt;n;i++)                {                    map_data[i] += 30;                }            }            else if(p == 'A'){                for(int i=0;i&lt;n;i++)                {                    tmp_map[i] = map_data[i];                }                for(int i=0;i&lt;n;i++)                {                    map_data[i] = tmp_map[(i+6)%n];                }            }            else if(p == 'S')            {                for(int i=0;i&lt;n;i++){                    map_data[i]=(map_data[i]&gt;&gt;5)|(map_data[i]&lt;&lt;3);                }            }            else if(p == 'W'){                for(int i=0;i&lt;n;i++){                    map_data[i]-=102;                }            }        }        MD5 md5 = MD5(map_data, n);        string hexd = md5.toStr();        cout &lt;&lt; \"round:\" &lt;&lt; rounds &lt;&lt; \" way: \" &lt;&lt; path &lt;&lt; \" md5: \" &lt;&lt; hexd &lt;&lt; \" \";        if (hexd == \"9c06c08f882d7981e91d663364ce5e2e\") {            cout &lt;&lt; \"found it\" &lt;&lt;  \"\\n\";            cout &lt;&lt; charArrayToHex(map_data, n);            exit(0);        } else {            cout &lt;&lt; \"nop\\n\";        }        if (rounds &gt; 1000) break;    }    return 0;}\n\nround:1 way: W md5: 62c753a165784d502246b51539f63797 nopround:2 way: WAS md5: ddf7a36ef6ee6dfc6dc91aad5d0dd21d nopround:3 way: WASA md5: 0f27f5aff365ec905bd9a5e4c60cd8b3 nopround:4 way: WASAWD md5: 9581209074985da9fa69047ce954c589 nopround:5 way: WASAWDSA md5: 6d87d9bc85ccf44e938dcb242d6baee3 nopround:6 way: WASAWDSAW md5: 30e6d405dd4d5e5af6d41f7ec1b1ab43 nopround:7 way: WASAWDSAWD md5: 587264015d204347a510bf2c72723097 nopround:8 way: WASAWDSAWDS md5: 6e3ab0e912c25e56c4283a011f2d2207 nopround:9 way: WASAWDSAWDSAW md5: 0a7b22abe33900efc2ae7f25f9950bb5 nopround:10 way: WASAWDSAWDSAWDS md5: 9c06c08f882d7981e91d663364ce5e2e found it48894c240855574881ec18020000488d6c2420488d7c2420b94e000000b8ccccccccf3ab488b8c2438020000c7450400000000c74524b979379eb804000000486bc000c744054857333163b804000000486bc001c7440548306d332eb804000000486bc002c744054820322051b804000000486bc003c744054857427338b804000000486bc000b904000000486bc900488b95100200008b040289440d78b804000000486bc001b904000000486bc901488b95100200008b040289440d78b804000000486bc002b904000000486bc902488b95100200008b040289440d78b804000000486bc003b904000000486bc903488b95100200008b040289440d78c785a400000000000000eb0e8b85a4000000ffc08985a400000083bda4000000200f83db000000b804000000486bc000b904000000486bc9018b4c0d78c1e104ba04000000486bd2018b541578c1ea0533caba04000000486bd201034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90089440d788b45248b4d0403c88bc1894504b804000000486bc001b904000000486bc9008b4c0d78c1e104ba04000000486bd2008b541578c1ea0533caba04000000486bd200034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90189440d78e90affffffc785c400000000000000eb0e8b85c4000000ffc08985c400000083bdc4000000200f83db000000b804000000486bc002b904000000486bc9038b4c0d78c1e104ba04000000486bd2038b541578c1ea0533caba04000000486bd203034c15788b550483e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90289440d788b45248b4d0403c88bc1894504b804000000486bc003b904000000486bc9028b4c0d78c1e104ba04000000486bd2028b541578c1ea0533caba04000000486bd202034c15788b5504c1ea0b83e2038bd28b549548448b45044403c2418bd033ca034c05788bc1b904000000486bc90389440d78e90affffffb804000000486bc000b904000000486bc9028b4c0d788b44057833c1b904000000486bc90089440d78b804000000486bc001b904000000486bc9038b4c0d788b44057833c1b904000000486bc90189440d78b804000000486bc003b904000000486bc9008b4c0d788b44057833c1b904000000486bc90389440d78b804000000486bc001b904000000486bc9028b4c0d788b44057833c1b904000000486bc90289440d78c685e800000098c685e9000000a0c685ea000000d9c685eb00000098c685ec000000bac685ed00000097c685ee0000001bc685ef00000071c685f00000009bc685f100000081c685f200000044c685f30000002fc685f400000055c685f5000000b8c685f600000037c685f7000000dfc7851401000000000000eb0e8b8514010000ffc089851401000083bd14010000107d25486385140100000fbe44057848638d140100000fbe8c0de80000003bc1740432c0eb04ebc4b001488bf890909090909090909090909090909090488bc7488da5f80100005f5dc3\n\n然后吧解出来内容直接用 IDA 分析，是个魔改 XTea + 异或，主要魔改点就是四个密文，前两个 delta 从 0开始加起，后两组的 delta 从 32 * delta 开始算起\n\n#include&lt;stdio.h&gt;int main() {    unsigned int enc[4] = {0x98d9a098,                           0x711b97ba,                           0x2f44819b,                           0xdf37b855};    int n = 4;    unsigned int key[4] = {0x63313357,                           0x2e336d30,                           0x51203220,                           0x38734257};    int i, j;    long sum = 0, delta = 0x9E3779B9;    enc[2] ^= enc[1];    enc[3] ^= enc[0];    enc[1] ^= enc[3];    enc[0] ^= enc[2];    for (i = 0; i &lt; n; i += 2) {        sum = (32 * delta * (i / 2 + 1));        for (j = 0; j &lt; 32; j++) {            enc[i + 1] -= (((enc[i] &gt;&gt; 5) ^ (16 * enc[i])) + enc[i]) ^ (key[((sum &gt;&gt; 11) &amp; 3)] + sum);//容易魔改            sum -= delta;            enc[i] -= (((enc[i + 1] &gt;&gt; 5) ^ (16 * enc[i + 1])) + enc[i + 1]) ^ (key[(sum &amp; 3)] + sum);//容易魔改        }    }    for (i = 0; i &lt; n; i++) {        for (j = 0; j &lt;= 3; j++) {            printf(\"%c\", (enc[i] &gt;&gt; (j * 8)) &amp; 0xFF);        }    }    return 0;}// flag{G0@d_Snake}\n\nmips一个魔改 qemu 题题目给了一个 mips 架构的 qemu-user-static，mips 本来是可以直接运行的，出题人给个模拟器，那么肯定是有怪的，观察到 emu 被出题人去符号了，所以先查字符串搜索到这是一个 qemu 6.2.0 的 user-static，然后拉一份源码自行编译 bindiff\n试过了许多优化等级，发现只有 -O0 的时候，符号还原率还有文件大小和题目给出的最相似编译命令 ../configure --extra-cflags=\"-O0\" --target-list=mips-linux-user\n然后 bindiff 就还原出了大部分的符号\n\n一开始想用 -g 选项直接调试 mips_bin，但是发现 原本的调试功能被作者去掉了，于是去分析\n\n\n在 0x000000000034B7A3 下找到了原本的 gdbserver_start，然后 patch 模拟器，打开调试功能\n\n\n\n\n然后使用 ./emu -g 1234 mips_bin2 打开gdb服务器，ida附加调试\n程序中还有一个 fork 会影响分析，虽然可以 patch 掉但是会导致 flag 验证结果错误。在分析过程中会发现一个比较简单的假 flag，如果不用模拟器，这个 flag 就是对的，那么想到应该是模拟器上做了手脚，单步调试，最后发现在 syscall 之前 输出内容并没有被修改，那么只能想到是 qemu 中的 do_syscall 被修改了\n\n\nwrite 的调用号是 0xFA4\n果不其然，这里有额外的逻辑通过交叉引用找到加密的逻辑\n\n\nsub_33D48E 是一个魔改的 RC4，其中还有一点花指令，让反编译不正常，修复后主要魔改在 RC4 最后一步的异或上\n\n然后是一个简单异或，异或的值在 qemu 中处理 fork() 指令的函数 do_fork() 中被修改了，所以说如果之前把 fork() patch掉了也会导致没法解出来\n\n\nsub_33D886 是一个换位函数，这里吧密文的 7,11 和 12,16 位进行了交换在了解所有加密逻辑后，写一个解密脚本\n#include &lt;iostream&gt;#include \"defs.h\"#include &lt;cstdint&gt;unsigned char a1[60] = {        0xA8, 0xAC, 0x36, 0x6A, 0xC4, 0x0A, 0x9A, 0xDC, 0x12, 0x48, 0xF2, 0x60, 0xCB, 0xCC, 0x3A, 0x5E,        0xF2, 0x63, 0x9C, 0x94, 0xF5, 0x48, 0xCD, 0x17, 0x82, 0xCD, 0xF7, 0x71, 0x9F, 0x36, 0xB4, 0x88,        0xAF, 0x5F, 0xDD, 0x64, 0x85, 0x96, 0xF7, 0x5E, 0xC4, 0x09, 0xAD, 0xDD, 0xAB, 0x16, 0x99, 0x60,        0x9B, 0xDE, 0xF5, 0x53, 0xC3, 0x21, 0xFC, 0x80, 0xF8, 0x10, 0xC7, 0x26};unsigned char byte_4020[6] = {        0x4F, 0x7D, 0x8E, 0x2B, 0x31, 0x9C};unsigned int enced[24] = {        0x000000C4, 0x000000EE, 0x0000003C, 0x000000BB, 0x000000E7, 0x000000FD, 0x00000067, 0x0000001D,        0x000000F8, 0x00000097, 0x00000068, 0x0000009D, 0x0000000B, 0x0000007F, 0x000000C7, 0x00000080,        0x000000DF, 0x000000F9, 0x0000004B, 0x000000A0, 0x00000046, 0x00000091, 0x00000000, 0x00000000};unsigned char byte_B9CA60[32] = {        0xDE, 0xAD, 0xBE, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};uint8_t reverse_operation(uint8_t v3) {    uint8_t temp = v3;    uint8_t part1 = (temp &amp; 0xC0) ^ 0xC0;  // High bits    uint8_t part2 = (temp &amp; 0x3F) ^ 0x3B;  // Low bits    uint8_t middle = (part1 &gt;&gt; 6) | (part2 &lt;&lt; 2);    uint8_t v2 = (middle &gt;&gt; 7) | (middle &lt;&lt; 1);    return v2;}char *__fastcall decrypt(unsigned char *a1){    int v1; // edx    unsigned __int8 v3; // [rsp+15h] [rbp-17Bh]    int i; // [rsp+18h] [rbp-178h]    int v5; // [rsp+1Ch] [rbp-174h]    unsigned int v6; // [rsp+20h] [rbp-170h]    int i_22; // [rsp+24h] [rbp-16Ch]    int j_t12; // [rsp+28h] [rbp-168h]    int j; // [rsp+2Ch] [rbp-164h]    int v10; // [rsp+30h] [rbp-160h]    int v11; // [rsp+34h] [rbp-15Ch]    int v12; // [rsp+3Ch] [rbp-154h]    const char *v13; // [rsp+40h] [rbp-150h]    char *v14; // [rsp+48h] [rbp-148h]    __int8 sbox[256]; // [rsp+80h] [rbp-110h] BYREF    __int16 v16; // [rsp+180h] [rbp-10h]    unsigned __int64 v17; // [rsp+188h] [rbp-8h]    memset(sbox, 0, sizeof(sbox));    v16 = 0;    for ( i = 0; i &lt;= 255; ++i )        sbox[i] = i;    v5 = 0;    v6 = 0;    v13 = \"6105t3\";    do    {        v10 = (unsigned __int8)sbox[v6];        v11 = (unsigned __int8)(v13++)[(int)(2 * (v6 / 6 - (((2863311531u * (unsigned __int64)v6) &gt;&gt; 32) &amp; 0xFFFFFFFC)))];        v5 += v10 + v11;        v1 = v6++;        sbox[v1] = sbox[(unsigned __int8)v5];        sbox[(unsigned __int8)v5] = v10;    }    while ( v6 != 256 );    i_22 = 0;    j_t12 = 0;    v14 = (char *) malloc(256LL);    for ( j = 0; j != 22; ++j )    {        v12 = (unsigned __int8)sbox[(unsigned __int8)++i_22];        j_t12 += v12;        sbox[(unsigned __int8)i_22] = sbox[(unsigned __int8)j_t12];        sbox[(unsigned __int8)j_t12] = v12;//        v3 = ((((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &lt;&lt; 6) ^ 0xC0 | (((a1[j] &lt;&lt; 7) | (a1[j] &gt;&gt; 1)) &gt;&gt; 2) ^ 0x3B) ^ 0xBE;//        v14[j] = sbox[(sbox[i_22] + v12)] ^ byte_B9CA60[j &amp; 3] ^ (((((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE) &gt;&gt; 5) | (8 * (((16 * (((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD)) | ((((32 * v3) | (v3 &gt;&gt; 3)) ^ 0xAD) &gt;&gt; 4)) ^ 0xDE)));        uint8 step1 = a1[j] ^ sbox[(unsigned __int8)(sbox[(unsigned __int8)i_22] + v12)] ^ byte_B9CA60[j &amp; 3];        uint8 s1_p1 = step1 &gt;&gt; 3 | step1 &lt;&lt; 5;        s1_p1 ^= 0xDE;        s1_p1 = s1_p1 &lt;&lt; 4 | s1_p1 &gt;&gt; 4;        s1_p1 ^= 0xAD;        s1_p1 = s1_p1 &lt;&lt; 3 | s1_p1 &gt;&gt; 5;        uint8 v3 = s1_p1;        v3 ^= 0xBE;        uint8 dt = reverse_operation(v3);        printf(\"%c\", dt);    }    return v14;}int main() {    uint32 tmp = enced[12];    enced[12] = enced[16];    enced[16] = tmp;    tmp = enced[7];    enced[7] = enced[11];    enced[11] = tmp;    uint8 css[24];    for (int i = 0; i &lt; 22; ++i) {        enced[i] ^= 0xA;        css[i] = (uint8) enced[i];    }    decrypt(css);    return 0;}// flag{QeMu_r3v3rs3in9_h@ck6}\n","tags":["Reverse"]},{"title":"2024 N1CTF - Reverse","url":"/2024/11/11/2024n1ctf/","content":"2024 N1CTF Reverse 方向 Writes UP\n\n\nReFantazio 三血，嘻嘻\nezapk\nenc 注册在 libnative1 里面，加密逻辑在 libnative2 里面，在三处 call 寄存器的地方下断点\n\n\n\n得到加密逻辑\n# iusp9aVAyoMI 异或 rand()# SZ3pMtlDTA7Q RC4 密钥是 rand()出来的# UqhYy0F049n5 base64编码\n\n由 RC4 的对称性可以想到一个简便解法，用 frida 下断在 JNI 函数处，覆写 GetStringUTFChars 得到的内存地址\n\n然后再在 ret 的位置 hook 拿到解密后的内容就可得到 flag\nvar inter = setInterval(function() {    try {        var module = Process.getModuleByName(\"libnative1.so\");        var write_data = [0x89,0x1a,0xcb,0xeb,0x7b,0x6f,0x7b,0xe1,0xfb,0xdb,0x08,0xeb,0xfc,0x71,0xe2,0xc2,0x55,0x6e,0xe5,0x16,0x54,0xf5,0x70,0xdc,0x23,0xb0];        Interceptor.attach(module.base.add(0x1B188), {            onEnter: function () {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))                ptr(reg).writeByteArray(write_data)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        Interceptor.attach(module.base.add(0x1B458), {            onEnter: function() {                var reg = this.context.x0.and(0xFFFFFFFFFFFF)                console.log(hexdump(reg, {length: 100, ansi: true}))            }        })        console.log(\"Hook successful!\")        clearInterval(inter)    } catch {}}, 50)\n\n\n\n\n\nReFantazio三血嘻嘻\n到手发现一个很大的 so，ida 查看字符串发现 frida 字样，那么大概是个内置 frida-gum 的程序\n第一步，先还原符号\n去拉一份最新的 frida 源码，先编译一遍，生成 frida-android-arm64 后修改内容\n\n\n先关优化，然后去修改 subprojects\\frida-core\\tools 下的 post-process.py\n\n\n关闭 strip\n然后就可以 bindiff 了\n在还原大部分符号后，可以发现这个从 bytes 创建脚本，那么大胆猜测是加载明文脚本\n\n\n所以可以写一个脚本 dump 所有内存段，然后搜索 Java.use 定位即可\nJava.perform(function() {    setTimeout(function() {        let allMemoryData = [];        let totalSize = 0;                const ranges = Process.enumerateRangesSync({            protection: '---',            coalesce: true        });                for (const range of ranges) {            try {                const current = range.base;                const size = range.size;                console.log(current, size)                const memoryData = Memory.readByteArray(current, size);                if (memoryData) {                    allMemoryData.push(memoryData);                    totalSize += size;                }            } catch {}        }        const finalBuffer = new ArrayBuffer(totalSize);        const finalArray = new Uint8Array(finalBuffer);        let offset = 0;                for (const data of allMemoryData) {            const tempArray = new Uint8Array(data);            finalArray.set(tempArray, offset);            offset += tempArray.length;        }                const timestamp = new Date().getTime();        const filename = `/data/data/com.android.refantazio/memory_dump_${timestamp}.bin`;        const file = new File(filename, \"wb\");        file.write(finalBuffer);        file.flush();        file.close();        console.log(`[+] Saved ${finalBuffer.byteLength} bytes to ${filename}`);    }, 3000)})// /data/data/com.android.refantazio/memory_dump_1731235293045.bin// /data/data/com.android.refantazio/memory_dump_1731235318417.bin\n\n得到转储文件后用 010 去搜\n\n\n就可以秒了\nlet t = [],n = \"n1cTfOwO\".length;for (let e = 0; e &lt; 256; e++) t[e] = e;let o = 0;for (let e = 0; e &lt; 256; e++) o = (o + t[e] + \"n1cTfOwO\".charCodeAt(e % n)) % 256,[t[e], t[o]] = [t[o], t[e]];let r = 0;o = 0;let i = [59, 67, 58, 32, 172, 94, 161, 232, 59, 225, 56, 210, 206, 94, 123, 253, 112, 252, 41, 136, 71, 102, 81, 80, 128, 39, 22, 44, 176, 41, 205, 197, 5, 247, 68, 151, 127, 29, 251, 58, 85];var dt = [];for (let n = 0; n &lt; 41; n++) {    o = (o + t[r = (r + 1) % 256]) % 256,    [t[r], t[o]] = [t[o], t[r]];    let l = t[(t[r] + t[o]) % 256];    dt.push(String.fromCharCode(i[n] ^ l));}console.log(dt.join(\"\"))\n\nBrokenApp一个简单鸿蒙题目，比赛的时候没想到 add xxx 是吧 栈顶取出然后在前面加上 xxx，导致 0 加到了字符串末尾，所以就一直解不出来。。。。。。拿到题目后第一步先反 modules.abc，这里我用的是 abc-decompiler\n\narkjs 层的代码是假的，关键去看 abc.defabc.def 是被魔改了的，我们去 libark_runtime.so 分析一下关键逻辑在这里，先把魔改的头部改回 PANDA，原本是 N1CTF\n\n然后把输入的 flag 填入 abc.def 以 0x1B5A80 开头的 40 个字节，\n\n然后继续加载，abc.def 没法反成 java 代码，所以我用了 abcde 反汇编，然后手动分析\nnewlexenv 2     tryldglobalbyname 0 \"require\"     sta v0     lda.str \"@babel/core\"     sta v1     lda v0     callarg1 1 v1     stconsttoglobalrecord 3 \"babel\"   tryldglobalbyname 4 \"require\"sta v0     lda.str \"@babel/parser\"     sta v1     lda v0     callarg1 5 v1     stconsttoglobalrecord 7 \"parser\"  tryldglobalbyname 8 \"require\"     sta v0     lda.str \"@babel/traverse\"     sta v1     lda v0     callarg1 9 v1     ldobjbyname 11 \"default\"     stconsttoglobalrecord 13 \"traverse\"  tryldglobalbyname 14 \"require\"     sta v0     lda.str \"@babel/types\"     sta v1     lda v0     callarg1 15 v1     stconsttoglobalrecord 17 \"t\"     tryldglobalbyname 18 \"require\"     sta v0     lda.str \"@babel/generator\"     sta v1     lda v0     callarg1 19 v1     ldobjbyname 21 \"default\"     stconsttoglobalrecord 23 \"generator\"    /* 上面都在导库 翻译过来就是const babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");*/lda.str \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"     stconsttoglobalrecord 24 \"FLAG\"     // const FLAG = \"N1CTF{padding_the_flag_here_XXXXXXXXXXX}\"lda.str \"const u = [        \"viKok6\",        \"xznLka\",        ... 这里省略    ];\"     stconsttoglobalrecord 25 \"code\"     /* code = \"    const u = [            \"viKok6\",            \"xznLka\",            ... 这里省略        ]; \"    */createemptyarray 26     stconsttoglobalrecord 27 \"u_\"     // const u_ = [];tryldglobalbyname 28 \"parser\"     sta v0     ldobjbyname 29 \"parse\"     sta v1     tryldglobalbyname 31 \"code\"     sta v2     lda v1     callthis1 32 v0 v2     stconsttoglobalrecord 34 \"ast\"     // const ast = parser.parse(code);tryldglobalbyname 35 \"traverse\"     sta v0     tryldglobalbyname 36 \"ast\"     sta v1     createobjectwithbuffer 37 { 3 [ str:\"enter\", Method:_GLOBAL.#*#enter, MethodAffiliate:1,  ]}     sta v2     lda v0     callargs2 38 v1 v2     /*这里是 调用 traverse, _GLOBAL.#*#enter之类的代码我已经提前翻译好了traverse(ast, {    enter: function(path) {        if (t.isArrayExpression(path.node)) {            path.node.elements.forEach((arg0, arg1) =&gt; {                if (t.isStringLiteral(arg0)) {                    if (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {                        const value = arg0.value;                        const index = (arg1 + 2) % 6;                        const result = value[index];                        u_.push(result);                    }                }            });        }    }});*/tryldglobalbyname 40 \"FLAG\"     sta v0     ldobjbyname 41 \"startsWith\"     sta v1     lda.str \"N1CTF{\"     sta v2     lda v1     callthis1 43 v0 v2     sta v0     callruntime.isfalse 45     jnez 27     tryldglobalbyname 46 \"FLAG\"     sta v0     ldobjbyname 47 \"endsWith\"     sta v1     lda.str \"}\"     sta v2     lda v1     callthis1 49 v0 v2     sta v0     lda v0     callruntime.isfalse 51     jnez 107     // if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) tryldglobalbyname 52 \"FLAG\"     sta v0     ldobjbyname 53 \"substring\"     sta v1     tryldglobalbyname 55 \"FLAG\"     ldobjbyname 56 \"length\"     sta v2     ldai 1     sub2 58 v2     sta v2     ldai 6     sta v3     lda v1     callthis2 59 v0 v3 v2     sta v0 // const flagContent = FLAG.substring(6, FLAG.length - 1);lda.str \"0\"     sta v1     tryldglobalbyname 61 \"u_\"     sta v2     ldobjbyname 62 \"join\"     sta v3     lda.str \"\"     sta v4     lda v3     callthis1 64 v2 v4     add2 66 v1 // 就是这里被坑惨了, arkts 的 add 是 操作数 + 栈顶值, 比赛的时候我是 u_.join(\"\") + \"0\" 死活做不出。。。。。。stricteq 67 v0     callruntime.isfalse 68     // flagContent === \"0\" + u_.join(\"\")    jnez 20     tryldglobalbyname 69 \"print\"     sta v0     lda.str \"You're awesome!\"     sta v1     lda v0     callarg1 70 v1     jmp 18     tryldglobalbyname 72 \"print\"     sta v0     lda.str \"What's wrong?\"     sta v1     lda v0     callarg1 73 v1     ldundefined     returnundefined     /*if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {    const flagContent = FLAG.substring(6, FLAG.length - 1);    if (flagContent === \"0\" + u_.join(\"\")) {        print(\"You're awesome!\");    } else {        print(\"What's wrong?\");    }}*/    # _GLOBAL.#*#enternewlexenv 2     lda NewTarget     stlexvar 0 0     lda this     stlexvar 0 1     tryldglobalbyname 0 \"t\"     sta v0     ldobjbyname 1 \"isArrayExpression\"     sta v1     lda arg0     ldobjbyname 3 \"node\"     sta v2     lda v1     callthis1 5 v0 v2     callruntime.isfalse 7     jnez 33     lda arg0     ldobjbyname 8 \"node\"     ldobjbyname 10 \"elements\"     sta v0     ldobjbyname 12 \"forEach\"     sta v1     definefunc 14 this.#*@0*# 2     sta v2     lda v1     callthis1 15 v0 v2     ldundefined     returnundefined    # _GLOBAL.#*@0*#tryldglobalbyname 0 \"t\"sta v0ldobjbyname 1 \"isStringLiteral\"callthis1 3 v0 arg0callruntime.isfalse 5jnez 77ldai 150greater 6 arg1callruntime.isfalse 7jnez 64ldai 182less 8 arg1callruntime.isfalse 9jnez 51tryldglobalbyname 10 \"u_\"sta v0ldobjbyname 11 \"push\"sta v1lda arg0ldobjbyname 13 \"value\"sta v2ldai 2add2 15 arg1sta v3ldai 6mod2 16 v3ldobjbyvalue 17 v2sta v2lda v1callthis1 19 v0 v2ldundefinedreturnundefined\n\nconst babel = require('@babel/core');const parser = require('@babel/parser');const traverse = require('@babel/traverse').default;const t = require('@babel/types');const generator = require('@babel/generator').default;const fs = require(\"fs\");var code = `const u = [        \"viKok6\",        \"xznLka\",        \"DsA1Pd\",        \"55MYVz\",        \"DoUoja\",        ...    ];`;const u_ = [];const ast = parser.parse(code);traverse(ast, {\tenter: function (path) {\t\tif (t.isArrayExpression(path.node)) {\t\t\tpath.node.elements.forEach((arg0, arg1) =&gt; {\t\t\t\tif (t.isStringLiteral(arg0)) {\t\t\t\t\tif (arg1 &gt; 150 &amp;&amp; arg1 &lt; 182) {\t\t\t\t\t\t// console.log(arg0, arg1);\t\t\t\t\t\tconst value = arg0.value;\t\t\t\t\t\tconst index = (arg1 + 2) % 6;\t\t\t\t\t\tconst result = value[index];\t\t\t\t\t\tconsole.log(value, index)\t\t\t\t\t\tu_.push(result);\t\t\t\t\t}\t\t\t\t}\t\t\t});\t\t}\t}});if (FLAG.startsWith(\"N1CTF{\") &amp;&amp; FLAG.endsWith(\"}\")) {\tconst flagContent = FLAG.substring(6, FLAG.length - 1);\tif (flagContent === \"0\" + u_.join(\"\")) {\t\tprint(\"You're awesome!\");\t} else {\t\tprint(\"What's wrong?\");\t}}// N1CTF{0KACtgWmvh3cMAHdUKeRbxfASt7CkBT}\n\n","tags":["Reverse"]},{"title":"OLLVM 解混淆学习","url":"/2024/10/12/deollvm/","content":"学习 OLLVM 解混淆\n\n\n开坑中。。。。\n\n","tags":["Reverse","Android","DEOLLVM"]},{"title":"常见加密解密编码算法","url":"/2024/10/06/encode_decode/","content":"常见的加密解密算法实现汇总\n\n\nHEX#include \"stdio.h\" // sprintf()函数声明所在的头文件char data[] = \"Hello World!!\\r\\n\";char res[32];int str_2_hex_str(char *dest, char *src){    int len = strlen(src); // 获取接收数据长度    int i,j;    for (i = 0, j = 0; i &lt; len; i++) {        sprintf(&amp;dest[j], \"%02X\", src[i]);        j+=2; // 每个16进制占2个长度    }    dest[j] = '\\0'; // 添加字符串结束符    return j; // 返回字符串长度}int len = str_2_hex_str(res, data);///////////////////////////////#include &lt;stdlib.h&gt; // 要使用strtol()库函数，需要包含头文件char data[] = \"48656C6C6F20576F726C6421210D0A\"; // 假如，我们接收到这样的数据char res[32]; // 储存转换后的结果int hex_str_2_str(char *dest, char *src){    int len = strlen(src); // 获取接收数据长度    int i,j;    for (i = 0, j = 0; i &lt; len; i+=2) { // 每次取两个字符        char tmp_buf[3]; // 每两个字符组成一个16进制字符串，同时结尾需要空字符来告诉编译器我们的是字符串        char *endptr; // 保存已转换数值后的下一个字符        // 以下为取待转换的16进制字符串        tmp_buf[0] = src[i];        tmp_buf[1] = src[i + 1];        tmp_buf[2] = '\\0'; // 记得添加空字符        // 转换成16进制，base传16即可        dest[j++] = strtol(tmp_buf, &amp;endptr, 16);    }    dest[j] = '\\0'; // 添加字符串结束符    return j;}int len = hex_str_2_str(res, data);\nBASE64//base64加密char base64[65] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";void encodeBase64(char* str,int len,char** in){        //读取3个字节zxc，转换为二进制01111010 01111000 01100011    //转换为4个6位字节，011110 100111 100001 100011    //不足8位在前补0，变成00011110 00100111 00100001 00100011    //若剩余的字节数不足以构成4个字节，补等号    int encodeStrLen = 1 + (len/3)*4 ,k=0;    encodeStrLen += len%3 ? 4 : 0;    char* encodeStr = (char*)(malloc(sizeof(char)*encodeStrLen));    for(int i=0;i&lt;len;i++){        if(len - i &gt;= 3){            encodeStr[k++] = base64[(unsigned char)str[i]&gt;&gt;2];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x03)&lt;&lt;4 | (unsigned char)str[++i]&gt;&gt;4];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x0f)&lt;&lt;2 | (unsigned char)str[++i]&gt;&gt;6];            encodeStr[k++] = base64[(unsigned char)str[i]&amp;0x3f];        }else if(len-i == 2){            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x03) &lt;&lt; 4 | ((unsigned char)str[++i] &gt;&gt; 4)];            encodeStr[k++] = base64[((unsigned char)str[i]&amp;0x0f) &lt;&lt; 2];            encodeStr[k++] = '=';        }else{            encodeStr[k++] = base64[(unsigned char)str[i] &gt;&gt; 2];            encodeStr[k++] = base64[((unsigned char)str[i] &amp; 0x03) &lt;&lt; 4];                                                                                                              //末尾补两个等于号            encodeStr[k++] = '=';            encodeStr[k++] = '=';        }    }    encodeStr[k] = '\\0';    *in = encodeStr;}/*** 解码既编码的逆过程，先找出编码后的字符在编码之前代表的数字* 编码中将3位个字符变成4个字符，得到这4个字符的每个字符代表的原本数字* 因为在编码中间每个字符用base64码表进行了替换，所以这里要先换回来* 在对换回来的数字进行位运算使其还原成3个字符*/void decodeBase64(char* str,int len,char** in){        char ascill[129];    int k = 0;    for(int i=0;i&lt;64;i++){        ascill[base64[i]] = k++;    }    int decodeStrlen = len / 4 * 3 + 1;    char* decodeStr = (char*)malloc(sizeof(char)*decodeStrlen);    k = 0;    for(int i=0;i&lt;len;i++){        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 2) | (ascill[str[++i]] &gt;&gt; 4);        if(str[i+1] == '='){            break;        }        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 4) |  (ascill[str[++i]] &gt;&gt; 2);        if(str[i+1] == '='){            break;        }        decodeStr[k++] = (ascill[str[i]] &lt;&lt; 6) | (ascill[str[++i]]);    }    decodeStr[k] = '\\0';    *in = decodeStr;}int main(){char mm[]=\"UAsFvs3tDyTxFPGb7WbyBYSm05VWrJxgjArj9mx490pfH1LO\";char *mm1;char *mm2;encodeBase64(mm,strlen(mm),&amp;mm1);decodeBase64(mm1,strlen(mm1),&amp;mm2);puts(mm2);}\nXXTEA#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))//容易魔改void btea(uint32_t * v, int n, uint32_t const key[4]) {//v为数据，n为数据长度(负时为解密)，key为密钥    uint32_t y,  z, sum;  unsigned p, rounds, e;    if (n &gt; 1)    /* Coding Part */    {        rounds = 6 + 52 / n;        sum = 0;        z = v[n - 1];        do {            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p = 0; p &lt; n - 1; p++) {                y = v[p + 1];                z = v[p] += MX;            }            y = v[0];            z = v[n - 1] += MX;        } while (-- rounds );    } else if (n &lt; -1)    /* Decoding Part */    {        n = -n;        rounds = 6 + 52 / n;        sum = rounds * DELTA;        y = v[0];        do {            e = (sum &gt;&gt; 2) &amp; 3;            for (p = n - 1; p &gt; 0; p--) {                z = v[p - 1];                y = v[p] -= MX;            }            z = v[n - 1];            y = v[0] -= MX;            sum -= DELTA;        } while (-- rounds );    }}\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define delta 0x9e3779b9int main(){    unsigned int v[8] = {0x10BD3B47, 0x6155E0F9, 0x6AF7EBC5, 0x8D23435F, 0x1A091605, 0xD43D40EF, 0xB4B16A67, 0x6B3578A9};    unsigned int key[4] = {0x00001234, 0x00002345, 0x00004567, 0x00006789};    unsigned int sum = 0;    unsigned int y, z, p, rounds, e;    int n = 8;    int i = 0;    rounds = 6 + 52 / n;    y = v[0];    sum = rounds * delta;    do    {        e = sum &gt;&gt; 2 &amp; 3;        for (p = n - 1; p &gt; 0; p--)        {            z = v[p - 1];            v[p] -= ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((key[(p &amp; 3) ^ e] ^ z) + (y ^ sum)));            y = v[p];        }        z = v[n - 1];        v[0] -= (((key[(p ^ e) &amp; 3] ^ z) + (y ^ sum)) ^ (((y &lt;&lt; 2) ^ (z &gt;&gt; 5)) + ((z &lt;&lt; 4) ^ (y &gt;&gt; 3))));        y = v[0];        sum = sum - delta;    } while (--rounds);    for (i = 0; i &lt; n; i++)    {        printf(\"%c%c%c%c\", *((char *)&amp;v[i] + 0), *((char *)&amp;v[i] + 1), *((char *)&amp;v[i] + 2), *((char *)&amp;v[i] + 3));        // printf(\"%c%c%c%c\",*((char*)&amp;v[i]+3),*((char*)&amp;v[i]+2),*((char*)&amp;v[i]+1),*((char*)&amp;v[i]+0));    }    return 0;}\n\nXTea#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x9E3779B9;    for (i = 0; i &lt; num_rounds; i++)    {        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);        sum += delta;        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);    }    v[0] = v0;    v[1] = v1;}void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]){    unsigned int i;    uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta * num_rounds;    for (i = 0; i &lt; num_rounds; i++)    {        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]);        sum -= delta;        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]);    }    v[0] = v0;    v[1] = v1;}\n\nTea#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void encrypt(uint32_t *v, uint32_t *k){    uint32_t v0 = v[0], v1 = v[1], sum = 0, i;    uint32_t delta = 0x9e3779b9;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {        sum += delta;        v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);    }    v[0] = v0;    v[1] = v1;}void decrypt(uint32_t *v, uint32_t *k){    uint32_t v0 = v[0], v1 = v[1], i;    uint32_t delta = 0x9e3779b9;    uint32_t sum = delta * 32;    uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];    for (i = 0; i &lt; 32; i++)    {        v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);        v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);        sum -= delta;    }    v[0] = v0;    v[1] = v1;}\n\nAES伪代码Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])begin    byte state[4, Nb]    state = in    AddRoundkey(state, w[0, Nb-1])    for round = 1 step 1 to Nr-1        SubBytes(state)        ShiftRows(state)        MixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    SubBytes(state)    ShiftRows(state)    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    out = stateendInvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr_1)])begin    byte stae[4, Nb]    state = in    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    for round = Nr-1 step -1 downto 1        InvShiftRows(state)        InvSubBytes(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])        InvMixColumns(state)    end    InvShiftRows(state)    InvSubBytes(state)    AddRoundKey(state, w[0, Nb-1])    out = stateend// 另一种等效的加解密步骤, Intel AES指令集采用的是这种步骤(两者加密密钥扩展是一样的)// SubBytes和ShiftRows可以交换// InvMixColumns(AddRoundKey(state, RoundKey)) = AddRoundKey(InvMixColumns(state), InvMixColumns(RoundKey)Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])begin    byte state[4, Nb]    state = in    AddRoundkey(state, w[0, Nb-1])    for round = 1 step 1 to Nr-1        ShiftRows(state)        SubBytes(state)        MixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    ShiftRows(state)    SubBytes(state)    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    out = stateendInvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr_1)])begin    byte stae[4, Nb]    state = in    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb - 1])    for round = Nr-1 step -1 downto 1        InvSubBytes(state)        InvShiftRows(state)        InvMixColumns(state)        AddRoundKey(state, w[round*Nb, (round+1)*Nb - 1])    end    InvSubBytes(state)    InvShiftRows(state)    AddRoundKey(state, w[0, Nb-1])    out = stateend// 解密密钥扩展需要增加如下步骤for i = 0 step 1 to (Nb*(Nr+1)-1)    dw[i] = w[i]end// 增加的运算for round=1 step 1 to Nr-1    InvMixColumns(dw[round*Nb, (round+1)*Nb-1])end for\n\n代码 1#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;void AddRoundKey(unsigned char *plaintext, unsigned char * CipherKey)/*轮密钥加*/{\tfor (int j = 0; j &lt; 16; j++)  plaintext[j] = plaintext[j] ^ CipherKey[j];}void SubBytes(unsigned char *plaintext, unsigned char *plaintextencrypt, int count)/*S盒置换*/{\tunsigned int row, column;\tunsigned char Sbox[16][16] = {\t\t      /* 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */\t\t/*0*/{ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76 },\t\t/*1*/{ 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0 },\t\t/*2*/{ 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15 },\t\t/*3*/{ 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75 },\t\t/*4*/{ 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84 },\t\t/*5*/{ 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf },\t\t/*6*/{ 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8 },\t\t/*7*/{ 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2 },\t\t/*8*/{ 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73 },\t\t/*9*/{ 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb },\t\t/*a*/{ 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79 },\t\t/*b*/{ 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08 },\t\t/*c*/{ 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a },\t\t/*d*/{ 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e },\t\t/*e*/{ 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf },\t\t/*f*/{ 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 }\t};// 填充Sbox矩阵\tfor (int i = 0; i &lt; count; i++)\t{\t\trow = (plaintext[i] &amp; 0xF0) &gt;&gt; 4;\t\tcolumn = plaintext[i] &amp; 0x0F;\t\tplaintextencrypt[i] = Sbox[row][column];\t}}void SubBytesRe(unsigned char *plaintext, unsigned char *plaintextencrypt, int count)/*S盒逆置换*/{\tunsigned int row, column;\tunsigned char Sbox[16][16] = {\t\t/* 0     1     2     3     4     5     6     7     8     9     a     b     c     d     e     f */\t\t{0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb},\t\t{0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb},\t\t{0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e},\t\t{0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25},\t\t{0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92},\t\t{0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84},\t\t{0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06},\t\t{0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b},\t\t{0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73},\t\t{0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e},\t\t{0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b},\t\t{0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4},\t\t{0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f},\t\t{0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef},\t\t{0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61},\t\t{0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d}\t};\t// 填充Sbox矩阵\tfor (int i = 0; i &lt; count; i++)\t{\t\trow = (plaintext[i] &amp; 0xF0) &gt;&gt; 4;\t\tcolumn = plaintext[i] &amp; 0x0F;\t\tplaintextencrypt[i] = Sbox[row][column];\t}}void ShiftRowsRe(unsigned char *plaintextencrypt)/*行移位的逆*/{\tunsigned char temp = 0;\tfor (int i = 0; i &lt; 4; i++)//第i行\t{\t\tfor (int j = 0; j &lt; 4 - i; j++)//第j次左移\t\t{\t\t\ttemp = plaintextencrypt[i];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\tplaintextencrypt[i + 4 * k] = plaintextencrypt[i + 4 * (k + 1)];\t\t\tplaintextencrypt[i + 12] = temp;\t\t}\t}}void ShiftRows(unsigned char *plaintextencrypt)/*行移位*/{\tunsigned char temp = 0;\tfor (int i = 0; i &lt; 4; i++)//第i行\t{\t\tfor (int j = 0; j &lt; i; j++)//第j次左移\t\t{\t\t\ttemp = plaintextencrypt[i];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\tplaintextencrypt[i + 4 * k] = plaintextencrypt[i + 4 * (k + 1)];\t\t\tplaintextencrypt[i + 12] = temp;\t\t}\t}}unsigned char Mult2(unsigned char num)/*列混淆*/{\tunsigned char temp = num &lt;&lt; 1;\tif ((num &gt;&gt; 7) &amp; 0x01)\t\ttemp = temp ^ 27;\treturn temp;}unsigned char Mult3(unsigned char num){\treturn Mult2(num) ^ num;}void MixColumns(unsigned char *plaintextencrypt, unsigned char *plaintextcrypt){\tint i;\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i] = Mult2(plaintextencrypt[4 * i]) ^ Mult3(plaintextencrypt[4 * i + 1]) ^ plaintextencrypt[4 * i + 2] ^ plaintextencrypt[4 * i + 3];\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 1] = plaintextencrypt[4 * i] ^ Mult2(plaintextencrypt[4 * i + 1]) ^ Mult3(plaintextencrypt[4 * i + 2]) ^ plaintextencrypt[4 * i + 3];\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 2] = plaintextencrypt[4 * i] ^ plaintextencrypt[4 * i + 1] ^ Mult2(plaintextencrypt[4 * i + 2]) ^ Mult3(plaintextencrypt[4 * i + 3]);\tfor (i = 0; i &lt; 4; i++)\t\tplaintextcrypt[4 * i + 3] = Mult3(plaintextencrypt[4 * i]) ^ plaintextencrypt[4 * i + 1] ^ plaintextencrypt[4 * i + 2] ^ Mult2(plaintextencrypt[4 * i + 3]);}/*逆列混淆*/ #define xtime(x)   ((x&lt;&lt;1) ^ (((x&gt;&gt;7) &amp; 1) * 0x1b))#define Multiply(x,y) (((y &amp; 1) * x) ^ ((y&gt;&gt;1 &amp; 1) * xtime(x)) ^ ((y&gt;&gt;2 &amp; 1) * xtime(xtime(x))) ^ ((y&gt;&gt;3 &amp; 1) * xtime(xtime(xtime(x)))) ^ ((y&gt;&gt;4 &amp; 1) * xtime(xtime(xtime(xtime(x))))))void MixColumnsRe(unsigned char *state){\t\tunsigned char a, b, c, d;\tfor (int i = 0; i &lt; 4; i++)\t{\t\ta = state[4*i];\t\tb = state[4*i+1];\t\tc = state[4*i+2];\t\td = state[4*i+3];\t\tstate[4 * i] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);\t\tstate[4 * i + 1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);\t\tstate[4 * i + 2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);\t\tstate[4 * i + 3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);\t}}int CharToWord(unsigned char *character, int first)/*字节转字*/{\treturn (((int)character[first] &amp; 0x000000ff) &lt;&lt; 24) | (((int)character[first + 1] &amp; 0x000000ff) &lt;&lt; 16) | (((int)character[first + 2] &amp; 0x000000ff) &lt;&lt; 8) | ((int)character[first + 3] &amp; 0x000000ff);}void WordToChar(unsigned int word, unsigned char *character)/*字转字节*/{\tfor (int i = 0; i &lt; 4; character[i++] = (word &gt;&gt; (8 * (3 - i))) &amp; 0xFF);}void ExtendCipherKey(unsigned int *CipherKey_word, int round)/*密钥扩展*/{\tunsigned char CipherKeyChar[4] = { 0 },CipherKeyCharEncrypt[4] = { 0 };\tunsigned int Rcon[10] = { 0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1B000000,0x36000000 };\t//轮常量\tfor (int i = 4; i &lt; 8; i++)\t{\t\tif (!(i % 4))\t\t{\t\t\tWordToChar((CipherKey_word[i - 1] &gt;&gt; 24) | (CipherKey_word[i - 1] &lt;&lt; 8), CipherKeyChar);\t\t\tSubBytes(CipherKeyChar, CipherKeyCharEncrypt, 4);\t\t\tCipherKey_word[i] = CipherKey_word[i - 4] ^ CharToWord(CipherKeyCharEncrypt, 0) ^ Rcon[round];\t\t}\t\telse\t\t\tCipherKey_word[i] = CipherKey_word[i - 4] ^ CipherKey_word[i - 1];\t}}void main(){\tprintf(\"**************AES加解密***************\\n\");\tint i = 0, k;\tunsigned char PlainText[16] = { 0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34 },\t\tCipherKey[16] = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c },\t\tCipherKey1[16] = { 0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c },\t\tPlainText1[16] = { 0 },\t\tPlainText2[16] = { 0 };\tunsigned int CipherKey_word[44] = { 0 };\tfor (i = 0; i &lt; 4; CipherKey_word[i++] = CharToWord(CipherKey, 4 * i));\tprintf(\"密钥：\");\tfor (k = 0; k &lt; 16; k++) printf(\"%2X \", CipherKey[k]);\tprintf(\"\\n明文：\");\tfor (k = 0; k &lt; 16; k++) printf(\"%02X \", PlainText[k]);\tprintf(\"\\n**************开始加密****************\");\tAddRoundKey(PlainText, CipherKey);\tfor (i = 0; i &lt; 9; i++)\t{\t\tprintf(\"\\n第%d轮循环：\\n\", i + 1);\t\tSubBytes(PlainText, PlainText1, 16);/*S盒置换*/\t\tShiftRows(PlainText1);\t/*行移位*/\t\tMixColumns(PlainText1, PlainText2);\t/*列混淆*/\t\tExtendCipherKey(CipherKey_word + 4 * i, i);/*子密钥生成*/\t\tfor (k = 0; k &lt; 4; k++)  WordToChar(CipherKey_word[k + 4 * (i + 1)], CipherKey + 4 * k);\t\tprintf(\"此时的子密钥为：    \");\t\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", CipherKey[k]);\t\tAddRoundKey(PlainText2, CipherKey);/*轮密钥加*/\t\tfor (k = 0; k &lt; 16; k++)  PlainText[k] = PlainText2[k];\t\tprintf(\"\\n当前明文加密之后为：\");\t\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", PlainText2[k]);\t\tprintf(\"\\n\");\t}\tprintf(\"\\n最后一次循环：\\n\");\tSubBytes(PlainText, PlainText1, 16);\tShiftRows(PlainText1);\tExtendCipherKey(CipherKey_word + 4 * i, i);\tfor (k = 0; k &lt; 4;WordToChar(CipherKey_word[k + 4 * (i + 1)], CipherKey + 4 * k), k++);\tprintf(\"此时的子密钥为：     \");\tfor (k = 0; k &lt; 16; k++)  printf(\"%02X \", CipherKey[k]);\tAddRoundKey(PlainText1, CipherKey);\tprintf(\"\\n\\n最终AES加密后的密文为：\");\tfor (i = 0; i &lt; 16; i++)  printf(\"%02X \", PlainText1[i]);\tprintf(\"\\n\\n**************开始解密***************\");\tAddRoundKey(PlainText1, CipherKey);\tfor (i = 0; i &lt; 9; i++)\t{\t\tprintf(\"\\n第%d次循环：\", i + 1);\t    SubBytesRe(PlainText1, PlainText, 16);/*S盒置换*/\t\tfor (k = 0; k &lt; 4; WordToChar(CipherKey_word[k + 40 - 4 * (i + 1)], CipherKey + 4 * k),k++);/*子密钥生成*/\t\tShiftRowsRe(PlainText);/*行移位逆*/\t\tAddRoundKey(PlainText, CipherKey);/*轮密钥加*/\t\tMixColumnsRe(PlainText);/*列混淆逆运算*/\t\tfor (k = 0; k &lt; 16;PlainText1[k] = PlainText[k],k++);\t\tprintf(\"\\n当前密文解密之后为：\");\t\tfor (k = 0; k &lt; 16; k++)printf(\"%02X \", PlainText[k]);\t\tprintf(\"\\n\");\t}\tprintf(\"\\n最后一次循环：\");\tShiftRowsRe(PlainText);/*行移位逆*/\tSubBytesRe(PlainText, PlainText1, 16);/*S盒置换*/\tAddRoundKey(PlainText1, CipherKey1);\tprintf(\"\\n最终AES解密后的明文为：\");\tfor (i = 0; i &lt; 16; i++)  printf(\"%02X \", PlainText1[i]);\tprintf(\"\\n\");\tsystem(\"pause\");}\n代码 2//// Created by Liming Shao on 2018/4/24.//#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct{    uint32_t eK[44], dK[44];    // encKey, decKey    int Nr; // 10 rounds} AesKey;#define BLOCKSIZE 16#define LOAD32H(x, y) \\  do { (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\             ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8)  | ((uint32_t)((y)[3] &amp; 0xff));} while(0)#define STORE32H(x, y) \\  do { (y)[0] = (uint8_t)(((x)&gt;&gt;24) &amp; 0xff); (y)[1] = (uint8_t)(((x)&gt;&gt;16) &amp; 0xff);   \\       (y)[2] = (uint8_t)(((x)&gt;&gt;8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); } while(0)/* extract a byte */#define BYTE(x, n) (((x) &gt;&gt; (8 * (n))) &amp; 0xff)/* used for keyExpansion */#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\                ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))#define ROF32(x, n)  (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))#define ROR32(x, n)  (((x) &gt;&gt; (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */static const uint32_t rcon[10] = {        0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL,        0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL};unsigned char S[256] = {        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};// unsigned char inv_S[256] = {//         0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,//         0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,//         0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,//         0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,//         0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,//         0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,//         0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,//         0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,//         0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,//         0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,//         0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,//         0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,//         0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,//         0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,//         0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,//         0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D// };unsigned char inv_S[256] = {      2, 15, 63, 202, 143, 30, 44, 208, 107, 138, 19, 1, 3, 189, 175, 193, 10, 211, 188, 140, 0, 171, 216, 144, 6, 69, 179, 184, 5, 88, 228, 247, 218, 185, 237, 253, 80, 72, 112, 108, 132, 157, 141, 167, 87, 70, 21, 94, 22, 152, 104, 134, 100, 246, 248, 114, 146, 182, 101, 93, 204, 92, 164, 212, 178, 36, 217, 40, 102, 161, 46, 8, 37, 209, 139, 109, 73, 162, 91, 118, 61, 35, 194, 166, 50, 148, 123, 84, 78, 195, 250, 66, 11, 149, 76, 238, 135, 255, 47, 155, 130, 57, 227, 124, 203, 233, 222, 196, 68, 67, 142, 52, 56, 165, 54, 48, 213, 106, 9, 82, 251, 215, 243, 129, 158, 163, 64, 191, 38, 214, 119, 186, 126, 4, 43, 23, 125, 12, 33, 85, 99, 20, 105, 225, 176, 245, 42, 174, 77, 59, 224, 160, 97, 153, 83, 131, 60, 187, 235, 200, 13, 74, 181, 25, 169, 127, 81, 96, 239, 156, 201, 147, 159, 122, 229, 45, 49, 199, 7, 136, 51, 168, 221, 31, 95, 236, 128, 39, 89, 16, 18, 177, 32, 121, 210, 198, 75, 62, 86, 252, 244, 90, 205, 120, 254, 192, 219, 154, 137, 197, 41, 29, 113, 26, 241, 71, 27, 190, 24, 170, 14, 98, 183, 111, 133, 53, 173, 231, 34, 116, 172, 150, 110, 223, 117, 28, 232, 55, 249, 226, 234, 220, 103, 79, 65, 17, 145, 58, 115, 230, 180, 240, 206, 207, 242, 151};/* copy in[16] to state[4][4] */int loadStateArray(uint8_t (*state)[4], const uint8_t *in) {    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[j][i] = *in++;        }    }    return 0;}/* copy state[4][4] to out[16] */int storeStateArray(uint8_t (*state)[4], uint8_t *out) {    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            *out++ = state[j][i];        }    }    return 0;}int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) {    if (NULL == key || NULL == aesKey){        printf(\"keyExpansion param is NULL\\n\");        return -1;    }    if (keyLen != 16){        printf(\"keyExpansion keyLen = %d, Not support.\\n\", keyLen);        return -1;    }    uint32_t *w = aesKey-&gt;eK;    uint32_t *v = aesKey-&gt;dK;    /* keyLen is 16 Bytes, generate uint32_t W[44]. */    /* W[0-3] */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(w[i], key + 4*i);    }    /* W[4-43] */    for (int i = 0; i &lt; 10; ++i) {        w[4] = w[0] ^ MIX(w[3]) ^ rcon[i];        w[5] = w[1] ^ w[4];        w[6] = w[2] ^ w[5];        w[7] = w[3] ^ w[6];        w += 4;    }    w = aesKey-&gt;eK+44 - 4;    for (int j = 0; j &lt; 11; ++j) {        for (int i = 0; i &lt; 4; ++i) {            v[i] = w[i];        }        w -= 4;        v += 4;    }    return 0;}int addRoundKey(uint8_t (*state)[4], const uint32_t *key) {    uint8_t k[4][4];    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            k[i][j] = (uint8_t) BYTE(key[j], 3 - i);  /* copy uint32 key[4] to uint8 k[4][4] */            state[i][j] ^= k[i][j];        }    }    return 0;}int subBytes(uint8_t (*state)[4]) {    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = S[state[i][j]];        }    }    return 0;}int invSubBytes(uint8_t (*state)[4]) {    /* i: row, j: col */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = inv_S[state[i][j]];        }    }    return 0;}int shiftRows(uint8_t (*state)[4]) {    uint32_t block[4] = {0};    /* i: row */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(block[i], state[i]);        block[i] = ROF32(block[i], 8*i);        STORE32H(block[i], state[i]);    }    return 0;}int invShiftRows(uint8_t (*state)[4]) {    uint32_t block[4] = {0};    /* i: row */    for (int i = 0; i &lt; 4; ++i) {        LOAD32H(block[i], state[i]);        block[i] = ROR32(block[i], 8*i);        STORE32H(block[i], state[i]);    }    return 0;}/* Galois Field (256) Multiplication of two Bytes */uint8_t GMul(uint8_t u, uint8_t v) {    uint8_t p = 0;    for (int i = 0; i &lt; 8; ++i) {        if (u &amp; 0x01) {    //            p ^= v;        }        int flag = (v &amp; 0x80);        v &lt;&lt;= 1;        if (flag) {            v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */        }        u &gt;&gt;= 1;    }    return p;}int mixColumns(uint8_t (*state)[4]) {    uint8_t tmp[4][4];    uint8_t M[4][4] = {{0x02, 0x03, 0x01, 0x01},                       {0x01, 0x02, 0x03, 0x01},                       {0x01, 0x01, 0x02, 0x03},                       {0x03, 0x01, 0x01, 0x02}};    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j){            tmp[i][j] = state[i][j];        }    }    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                        ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        }    }    return 0;}int invMixColumns(uint8_t (*state)[4]) {    uint8_t tmp[4][4];    uint8_t M[4][4] = {{0x0E, 0x0B, 0x0D, 0x09},                       {0x09, 0x0E, 0x0B, 0x0D},                       {0x0D, 0x09, 0x0E, 0x0B},                       {0x0B, 0x0D, 0x09, 0x0E}};    /* copy state[4][4] to tmp[4][4] */    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j){            tmp[i][j] = state[i][j];        }    }    for (int i = 0; i &lt; 4; ++i) {        for (int j = 0; j &lt; 4; ++j) {            state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j])                          ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]);        }    }    return 0;}int aesEncrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *pt, uint8_t *ct, uint32_t len) {    AesKey aesKey;    uint8_t *pos = ct;    const uint32_t *rk = aesKey.eK;    uint8_t out[BLOCKSIZE] = {0};    uint8_t actualKey[16] = {0};    uint8_t state[4][4] = {0};    if (NULL == key || NULL == pt || NULL == ct){        printf(\"param err.\\n\");        return -1;    }    if (keyLen &gt; 16){        printf(\"keyLen must be 16.\\n\");        return -1;    }    if (len % BLOCKSIZE){        printf(\"inLen is invalid.\\n\");        return -1;    }    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);    for (int i = 0; i &lt; len; i += BLOCKSIZE) {        loadStateArray(state, pt);        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) {            rk += 4;            subBytes(state);            shiftRows(state);            mixColumns(state);            addRoundKey(state, rk);        }        subBytes(state);        shiftRows(state);        addRoundKey(state, rk+4);        storeStateArray(state, pos);        pos += BLOCKSIZE;        pt += BLOCKSIZE;        rk = aesKey.eK;    }    return 0;}int aesDecrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *ct, uint8_t *pt, uint32_t len) {    AesKey aesKey;    uint8_t *pos = pt;    const uint32_t *rk = aesKey.dK;    uint8_t out[BLOCKSIZE] = {0};    uint8_t actualKey[16] = {0};    uint8_t state[4][4] = {0};    if (NULL == key || NULL == ct || NULL == pt){        printf(\"param err.\\n\");        return -1;    }    if (keyLen &gt; 16){        printf(\"keyLen must be 16.\\n\");        return -1;    }    if (len % BLOCKSIZE){        printf(\"inLen is invalid.\\n\");        return -1;    }    memcpy(actualKey, key, keyLen);    keyExpansion(actualKey, 16, &amp;aesKey);    for (int i = 0; i &lt; len; i += BLOCKSIZE) {        loadStateArray(state, ct);        addRoundKey(state, rk);        for (int j = 1; j &lt; 10; ++j) {            rk += 4;            invShiftRows(state);            invSubBytes(state);            addRoundKey(state, rk);            invMixColumns(state);        }        invSubBytes(state);        invShiftRows(state);        addRoundKey(state, rk+4);        storeStateArray(state, pos);        pos += BLOCKSIZE;        ct += BLOCKSIZE;        rk = aesKey.dK;    }    return 0;}void printHex(const uint8_t *ptr, int len, char *tag) {    printf(\"%s\\ndata[%d]: \", tag, len);    for (int i = 0; i &lt; len; ++i) {        printf(\"%.2X \", *ptr++);    }    printf(\"\\n\");}void printState(uint8_t (*state)[4], char *tag) {    printf(\"%s\\n\", tag);    for (int i = 0; i &lt; 4; ++i) {        printf(\"%.2X %.2X %.2X %.2X\\n\", state[i][0], state[i][1], state[i][2], state[i][3]);    }    printf(\"\\n\");}int main() {    // case 1    const uint8_t key[16] = { 0x05,0x06,0x07,0x08,0x37,0x42,0x4d,0x58,0x63,0x00,0x0a,0x0c,0x0d,0x0e,0x0f,0x10 };    const uint8_t pt[48]={         0x71,0x55,0x7f,0xa8,0xfa,0x0e,0xa3,0x19,0xa0,0x5c,0xf9,0x0e,0x9b,0x0b,0x5e,0xfc,0xb5,0xa8,0x49,0xfd,0x90,0x99,0x74,0xc7,0x77,0x02,0x6a,0xf5,0x9a,0x6a,0xba,0x7f,0xfb,0xe7,0x68,0xda,0x54,0xee,0xe8,0xbb,0x78,0x01,0xe7,0xbb,0xa2,0x95,0x95,0xfa,0x00,0x00    };    uint8_t ct[48] = {0};    uint8_t plain[48] = {0};     // aesEncrypt(key, 16, pt, ct, 16);    // printHex(pt, 16, \"plain data:\");    // printf(\"expect cipher:\\n39 25 84 1D 02 DC 09 FB DC 11 85 97 19 6A 0B 32\\n\");    // printHex(ct, 16, \"after encryption:\");    aesDecrypt(key, 16, pt, plain, 48);    printHex(plain, 48, \"after decryption:\");    // // case 2    // const uint8_t key2[]=\"1234567890123456\";    // const uint8_t *data = (uint8_t*)\"abcdefghijklmnopqrstuvwxyz123456\";    // uint8_t ct2[32] = {0};    // uint8_t plain2[32] = {0};    // aesEncrypt(key2, 16, data, ct2, 32);    // printf(\"\\nplain text:\\n%s\\n\", data);    // printf(\"expect ciphertext:\\nfcad715bd73b5cb0488f840f3bad7889\\n\");    // printHex(ct2, 32, \"after encryption:\");    // aesDecrypt(key2, 16, ct2, plain2, 32);    // printHex(plain2, 32, \"after decryption:\");    // printf(\"output plain text\\n\");    // for (int i = 0; i &lt; 32; ++i) {    //     printf(\"%c \", plain2[i]);    // }    return 0;}\n\n逆盒脚本#include \"stdio.h\"#include \"stdint.h\"unsigned char S[256] = {    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16};uint8_t INV_S[256] = {};int main() {    for (size_t i = 0; i &lt; 256; i++)    {        // 脱裤子放屁，，， 等于 INV_S[S[i]] = i;        INV_S[(((S[i] &amp; 0xF0) &gt;&gt; 4) &lt;&lt; 4) + (S[i] &amp; 0xF)] = i;    }    for (size_t i = 0; i &lt; 256; i++)    {        printf(\"%x\", INV_S[i]);        if (i &lt; 255) printf(\", \");    }    printf(\"\\n\");        return 0;}\n\nBlowFish// 轮函数DWORD Feistel(DWORD x){\tDWORD h = S[0][x &gt;&gt; 24] + S[1][x &gt;&gt; 16 &amp; 0xff];\treturn (h ^ S[2][x &gt;&gt; 8 &amp; 0xff]) + S[3][x &amp; 0xff];}void encrypt(DWORD&amp; XL, DWORD&amp; XR){\tfor (int i = 0; i &lt; 16; i += 2)\t{\t\tXL ^= P[i];\t\tXR ^= Feistel(XL);\t\tXR ^= P[i + 1];\t\tXL ^= Feistel(XR);\t}\tXL ^= P[16];\tXR ^= P[17];\tswap(XL, XR);}void decrypt(DWORD&amp; XL, DWORD&amp; XR){\tfor (int i = 16; i &gt; 0; i -= 2)\t{\t\tXL ^= P[i + 1];\t\tXR ^= Feistel(XL);\t\tXR ^= P[i];\t\tXL ^= Feistel(XR);\t}\tXL ^= P[1];\tXR ^= P[0];\tswap(XL, XR);}\n\nfrom Crypto.Cipher import Blowfishimport codecsclass BlowfishCipher:    def __init__(self):        pass    def encrypt(self, plaintext, key):        key = key.encode(\"utf-8\")        cipher = Blowfish.new(key, Blowfish.MODE_ECB)                # 将明文填充到8字节的倍数        plaintext = plaintext.ljust((len(plaintext) + 7) // 8 * 8)                ciphertext = cipher.encrypt(plaintext.encode('utf-8'))        hex_encode = codecs.encode(ciphertext, 'hex_codec').decode('utf-8')        return hex_encode    def decrypt(self, ciphertext, key):        key = key.encode(\"utf-8\")        cipher = Blowfish.new(key, Blowfish.MODE_ECB)                ciphertext = codecs.decode(ciphertext, 'hex_codec')        decrypted_text = cipher.decrypt(ciphertext).decode('utf-8').rstrip()        return decrypted_textif __name__ == '__main__':    plaintext = ''    key = 'UzBtZTBuZV9EMGcz'        blowfish_cipher = BlowfishCipher()    encrypted_text='11a51f049550e2508f17e16cf1632b47'    decrypted_text = blowfish_cipher.decrypt(encrypted_text, key)    print(f\"加密: {encrypted_text}, 解密: {decrypted_text}\")\n\nSM4加解密同源\n代码1#include&lt;stdio.h&gt;#define u8 unsigned char#define u32 unsigned long// S盒const u8 Sbox[256] = {\t0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,\t0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,\t0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,\t0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,\t0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,\t0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,\t0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,\t0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,\t0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,\t0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,\t0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,\t0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,\t0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,\t0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,\t0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,\t0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48};\t// 密钥扩展算法的常数FK const u32 FK[4] = {\t0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc};// 密钥扩展算法的固定参数CK const u32 CK[32] = {\t0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,\t0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,\t0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,\t0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,\t0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,\t0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,\t0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,\t0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279};u32 functionB(u32 b); // 查S盒的函数B u32 loopLeft(u32 a, short length); // 循环左移函数 u32 functionL1(u32 a); // 线性变换Lu32 functionL2(u32 a); // 线性变换L'u32 functionT(u32 a, short mode); // 合成变换Tvoid extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法void iterate32(u32 X[], u32 RK[]); // 迭代算法void reverse(u32 X[], u32 Y[]); // 反转函数 void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法 /*\t查S盒的函数B \t参数:\tu32 b\t返回值:\t查S盒的结果u32 b*/ u32 functionB(u32 b) {\tu8 a[4];\tshort i;\ta[0] = b / 0x1000000;\ta[1] = b / 0x10000;\ta[2] = b / 0x100;\ta[3] = b;\tb = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]];\treturn b;}/*\t循环左移算法\t参数：\tu32 a    length：循环左移位数\t返回值：u32 b */u32 loopLeft(u32 a, short length) {\tshort i;\tfor(i = 0; i &lt; length; i++) {\t\ta = a * 2 + a / 0x80000000;\t}\treturn a;}/* \t密钥线性变换函数L\t参数：\tu32 a\t返回值：线性变换后的u32 a\t*/u32 functionL1(u32 a) {\treturn a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24);}/* \t密钥线性变换函数L'\t参数：\tu32 a\t返回值：移位操作后的u32 a\t*/u32 functionL2(u32 a) {\treturn a ^ loopLeft(a, 13) ^ loopLeft(a, 23);}/*\t合成变换T\t参数：\tu32 a    short mode：1表示明文的T，调用L；2表示密钥的T，调用L' \t返回值：合成变换后的u32 a */u32 functionT(u32 a, short mode) {\treturn mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a));} /* \t密钥扩展算法第一步\t参数：\tMK[4]：密钥  K[4]:中间数据，保存结果\t（FK[4]：常数） \t返回值：无 */ void extendFirst(u32 MK[], u32 K[]) {\tint i;\tfor(i = 0; i &lt; 4; i++) {\t\tK[i] = MK[i] ^ FK[i]; \t} }/* \t密钥扩展算法第二步\t参数：\tRK[32]：轮密钥，保存结果    K[4]：中间数据 （CK[32]：固定参数） \t返回值：无*/ void extendSecond(u32 RK[], u32 K[]) {\tshort i;\tfor(i = 0; i &lt;32; i++) {\t\tK[(i+4)%4] = K[i%4] ^ functionT(K[(i+1)%4] ^ K[(i+2)%4] ^ K[(i+3)%4] ^ CK[i], 2);\t\tRK[i] = K[(i+4)%4];\t} }/*\t密钥扩展算法 \t参数：\tMK[4]：密钥     K[4]：中间数据    RK[32]：轮密钥，保存结果 \t返回值：无 */ void getRK(u32 MK[], u32 K[], u32 RK[]) {\textendFirst(MK, K);\textendSecond(RK, K);}/*\t迭代32次\t参数：\tu32 X[4]：迭代对象，保存结果    u32 RK[32]：轮密钥\t返回值：无\t  */void iterate32(u32 X[], u32 RK[]) {\tshort i;\tfor(i = 0; i &lt; 32; i++) {\t\tX[(i+4)%4] = X[i%4] ^ functionT(X[(i+1)%4] ^ X[(i+2)%4] ^ X[(i+3)%4] ^ RK[i], 1);\t}}/*\t反转函数 \t参数；\tu32 X[4]：反转对象    u32 Y[4]：反转结果\t返回值：无 */void reverse(u32 X[], u32 Y[]) {\t short i;\t for(i = 0; i &lt; 4; i++){\t \tY[i] = X[4 - 1 - i];\t } } /*\t加密算法\t参数：\tu32 X[4]：明文    u32 RK[32]：轮密钥    u32 Y[4]：密文，保存结果 \t返回值：无 */void encryptSM4(u32 X[], u32 RK[], u32 Y[]) {\titerate32(X, RK);\treverse(X, Y);} /*\t解密算法\t参数： \tu32 X[4]：密文    u32 RK[32]：轮密钥    u32 Y[4]：明文，保存结果\t返回值：无 */void decryptSM4(u32 X[], u32 RK[], u32 Y[]) {\tshort i;\tu32 reverseRK[32];\tfor(i = 0; i &lt; 32; i++) {\t\treverseRK[i] = RK[32-1-i];\t}\titerate32(X, reverseRK);\treverse(X, Y);} /*\t测试数据：\t明文：\t01234567 89abcdef fedcba98 76543210\t密钥：\t01234567 89abcdef fedcba98 76543210\t密文：\t681edf34 d206965e 86b3e94f 536e4246 */int main(void) {\tu32 X[4]; // 明文 \tu32 MK[4]; // 密钥 \tu32 RK[32]; // 轮密钥  \tu32 K[4]; // 中间数据 \tu32 Y[4]; // 密文 \tshort i; // 临时变量 \tprintf(\"明文：\"); \tscanf(\"%8x%8x%8x%8x\", &amp;X[0], &amp;X[1], &amp;X[2], &amp;X[3]);\tprintf(\"密钥：\"); \tscanf(\"%8x%8x%8x%8x\", &amp;MK[0], &amp;MK[1], &amp;MK[2], &amp;MK[3]);\tprintf(\"**************生成轮密钥*****************\\n\"); \tgetRK(MK, K, RK);\tfor(i = 0; i &lt; 32; i++) {\t\tprintf(\"[%2d]：%08x    \", i, RK[i]);\t\tif(i%4 == 3)\tprintf(\"\\n\"); \t}\tprintf(\"************** 生成密文 *****************\\n\"); \tencryptSM4(X, RK, Y);\tprintf(\"%08x %08x %08x %08x\\n\", Y[0], Y[1], Y[2], Y[3]);\tprintf(\"************** 生成明文 *****************\\n\");  \tdecryptSM4(Y, RK, X);\tprintf(\"%08x %08x %08x %08x\\n\", X[0], X[1], X[2], X[3]);\treturn 0;\t} \n\n代码2/* * SM4 Encryption alogrithm (SMS4 algorithm) * GM/T 0002-2012 Chinese National Standard ref:http://www.oscca.gov.cn/  * thanks to Xyssl * thnaks and refers to http://hi.baidu.com/numax/blog/item/80addfefddfb93e4cf1b3e61.html * author:goldboar * email:goldboar@163.com * 2012-4-20 */#define SM4_ENCRYPT     1#define SM4_DECRYPT     0/** * \\brief          SM4 context structure */typedef struct{    int mode;                   /*!&lt;  encrypt/decrypt   */    unsigned long sk[32];       /*!&lt;  SM4 subkeys       */}sm4_context;/** * \\brief          SM4 key schedule (128-bit, encryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_enc( sm4_context *ctx, unsigned char key[16] );/** * \\brief          SM4 key schedule (128-bit, decryption) * * \\param ctx      SM4 context to be initialized * \\param key      16-byte secret key */void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] );/** * \\brief          SM4-ECB block encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param input    input block * \\param output   output block */void sm4_crypt_ecb( sm4_context *ctx,                     int mode,                     int length,                     unsigned char *input,                     unsigned char *output);/** * \\brief          SM4-CBC buffer encryption/decryption * \\param ctx      SM4 context * \\param mode     SM4_ENCRYPT or SM4_DECRYPT * \\param length   length of the input data * \\param iv       initialization vector (updated after use) * \\param input    buffer holding the input data * \\param output   buffer holding the output data */void sm4_crypt_cbc( sm4_context *ctx,                     int mode,                     int length,                     unsigned char iv[16],                     unsigned char *input,                     unsigned char *output );                     // Test vector 1// plain: 01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10// key:   01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10// \t   round key and temp computing result://     rk[ 0] = f12186f9 X[ 0] = 27fad345//     rk[ 1] = 41662b61 X[ 1] = a18b4cb2//     rk[ 2] = 5a6ab19a X[ 2] = 11c1e22a//     rk[ 3] = 7ba92077 X[ 3] = cc13e2ee//     rk[ 4] = 367360f4 X[ 4] = f87c5bd5//     rk[ 5] = 776a0c61 X[ 5] = 33220757//     rk[ 6] = b6bb89b3 X[ 6] = 77f4c297//     rk[ 7] = 24763151 X[ 7] = 7a96f2eb//     rk[ 8] = a520307c X[ 8] = 27dac07f//     rk[ 9] = b7584dbd X[ 9] = 42dd0f19//     rk[10] = c30753ed X[10] = b8a5da02//     rk[11] = 7ee55b57 X[11] = 907127fa//     rk[12] = 6988608c X[12] = 8b952b83//     rk[13] = 30d895b7 X[13] = d42b7c59//     rk[14] = 44ba14af X[14] = 2ffc5831//     rk[15] = 104495a1 X[15] = f69e6888//     rk[16] = d120b428 X[16] = af2432c4//     rk[17] = 73b55fa3 X[17] = ed1ec85e//     rk[18] = cc874966 X[18] = 55a3ba22//     rk[19] = 92244439 X[19] = 124b18aa//     rk[20] = e89e641f X[20] = 6ae7725f//     rk[21] = 98ca015a X[21] = f4cba1f9//     rk[22] = c7159060 X[22] = 1dcdfa10//     rk[23] = 99e1fd2e X[23] = 2ff60603//     rk[24] = b79bd80c X[24] = eff24fdc//     rk[25] = 1d2115b0 X[25] = 6fe46b75//     rk[26] = 0e228aeb X[26] = 893450ad//     rk[27] = f1780c81 X[27] = 7b938f4c//     rk[28] = 428d3654 X[28] = 536e4246//     rk[29] = 62293496 X[29] = 86b3e94f//     rk[30] = 01cf72e5 X[30] = d206965e//     rk[31] = 9124a012 X[31] = 681edf34// cypher: 68 1e df 34 d2 06 96 5e 86 b3 e9 4f 53 6e 42 46// \t\t// test vector 2// the same key and plain 1000000 times coumpting // plain:  01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10// key:    01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10// cypher: 59 52 98 c7 c6 fd 27 1f 04 02 f8 04 c3 3d 3f 66#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;/* * 32-bit integer manipulation macros (big endian) */#ifndef GET_ULONG_BE#define GET_ULONG_BE(n,b,i)                             \\{                                                       \\    (n) = ( (unsigned long) (b)[(i)    ] &lt;&lt; 24 )        \\        | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 )        \\        | ( (unsigned long) (b)[(i) + 2] &lt;&lt;  8 )        \\        | ( (unsigned long) (b)[(i) + 3]       );       \\}#endif#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i)                             \\{                                                       \\    (b)[(i)    ] = (unsigned char) ( (n) &gt;&gt; 24 );       \\    (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 );       \\    (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt;  8 );       \\    (b)[(i) + 3] = (unsigned char) ( (n)       );       \\}#endif/* *rotate shift left marco definition * */#define  SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a,b) { unsigned long t = a; a = b; b = t; t = 0; }/* * Expanded SM4 S-boxes /* Sbox table: 8bits input convert to 8 bits output*/ static const unsigned char SboxTable[16][16] = {{0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05},{0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99},{0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62},{0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6},{0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8},{0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35},{0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87},{0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e},{0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1},{0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3},{0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f},{0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51},{0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8},{0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0},{0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84},{0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48}};/* System parameter */static const unsigned long FK[4] = {0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc};/* fixed parameter */static const unsigned long CK[32] ={0x00070e15,0x1c232a31,0x383f464d,0x545b6269,0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,0x30373e45,0x4c535a61,0x686f767d,0x848b9299,0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,0x10171e25,0x2c333a41,0x484f565d,0x646b7279};/* * private function: * look up in SboxTable and get the related value. * args:    [in] inch: 0x00~0xFF (8 bits unsigned value). */static unsigned char sm4Sbox(unsigned char inch){    unsigned char *pTable = (unsigned char *)SboxTable;    unsigned char retVal = (unsigned char)(pTable[inch]);    return retVal;}/* * private F(Lt) function: * \"T algorithm\" == \"L algorithm\" + \"t algorithm\". * args:    [in] a: a is a 32 bits unsigned value; * return: c: c is calculated with line algorithm \"L\" and nonline algorithm \"t\" */static unsigned long sm4Lt(unsigned long ka){    unsigned long bb = 0;    unsigned long c = 0;    unsigned char a[4];\tunsigned char b[4];    PUT_ULONG_BE(ka,a,0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);\tGET_ULONG_BE(bb,b,0)    c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24));    return c;}/* * private F function: * Calculating and getting encryption/decryption contents. * args:    [in] x0: original contents; * args:    [in] x1: original contents; * args:    [in] x2: original contents; * args:    [in] x3: original contents; * args:    [in] rk: encryption/decryption key; * return the contents of encryption/decryption contents. */static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk){    return (x0^sm4Lt(x1^x2^x3^rk));}/* private function: * Calculating round encryption key. * args:    [in] a: a is a 32 bits unsigned value; * return: sk[i]: i{0,1,2,3,...31}. */static unsigned long sm4CalciRK(unsigned long ka){    unsigned long bb = 0;    unsigned long rk = 0;    unsigned char a[4];    unsigned char b[4];    PUT_ULONG_BE(ka,a,0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);\tGET_ULONG_BE(bb,b,0)    rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23));    return rk;}static void sm4_setkey( unsigned long SK[32], unsigned char key[16] ){    unsigned long MK[4];    unsigned long k[36];    unsigned long i = 0;    GET_ULONG_BE( MK[0], key, 0 );    GET_ULONG_BE( MK[1], key, 4 );    GET_ULONG_BE( MK[2], key, 8 );    GET_ULONG_BE( MK[3], key, 12 );    k[0] = MK[0]^FK[0];    k[1] = MK[1]^FK[1];    k[2] = MK[2]^FK[2];    k[3] = MK[3]^FK[3];    for(; i&lt;32; i++)    {        k[i+4] = k[i] ^ (sm4CalciRK(k[i+1]^k[i+2]^k[i+3]^CK[i]));        SK[i] = k[i+4];\t}}/* * SM4 standard one round processing * */static void sm4_one_round( unsigned long sk[32],                    unsigned char input[16],                    unsigned char output[16] ){    unsigned long i = 0;    unsigned long ulbuf[36];    memset(ulbuf, 0, sizeof(ulbuf));    GET_ULONG_BE( ulbuf[0], input, 0 )    GET_ULONG_BE( ulbuf[1], input, 4 )    GET_ULONG_BE( ulbuf[2], input, 8 )    GET_ULONG_BE( ulbuf[3], input, 12 )    while(i&lt;32)    {        ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG//        \tprintf(\"rk(%02d) = 0x%08x,  X(%02d) = 0x%08x \\n\",i,sk[i], i, ulbuf[i+4] );// #endif\t    i++;    }\tPUT_ULONG_BE(ulbuf[35],output,0);\tPUT_ULONG_BE(ulbuf[34],output,4);\tPUT_ULONG_BE(ulbuf[33],output,8);\tPUT_ULONG_BE(ulbuf[32],output,12);}/* * SM4 key schedule (128-bit, encryption) */void sm4_setkey_enc( sm4_context *ctx, unsigned char key[16] ){    ctx-&gt;mode = SM4_ENCRYPT;\tsm4_setkey( ctx-&gt;sk, key );}/* * SM4 key schedule (128-bit, decryption) */void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] ){    int i;\tctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey( ctx-&gt;sk, key );    for( i = 0; i &lt; 16; i ++ )    {        SWAP( ctx-&gt;sk[ i ], ctx-&gt;sk[ 31-i] );    }}/* * SM4-ECB block encryption/decryption */void sm4_crypt_ecb( sm4_context *ctx,\t\t\t\t   int mode,\t\t\t\t   int length,\t\t\t\t   unsigned char *input,                   unsigned char *output){    while( length &gt; 0 )    {        sm4_one_round( ctx-&gt;sk, input, output );        input  += 16;        output += 16;        length -= 16;    }}/* * SM4-CBC buffer encryption/decryption */void sm4_crypt_cbc( sm4_context *ctx,                    int mode,                    int length,                    unsigned char iv[16],                    unsigned char *input,                    unsigned char *output ){    int i;    unsigned char temp[16];    if( mode == SM4_ENCRYPT )    {        while( length &gt; 0 )        {            for( i = 0; i &lt; 16; i++ )                output[i] = (unsigned char)( input[i] ^ iv[i] );            sm4_one_round( ctx-&gt;sk, output, output );            memcpy( iv, output, 16 );            input  += 16;            output += 16;            length -= 16;        }    }    else /* SM4_DECRYPT */    {        while( length &gt; 0 )        {            memcpy( temp, input, 16 );            sm4_one_round( ctx-&gt;sk, input, output );            for( i = 0; i &lt; 16; i++ )                output[i] = (unsigned char)( output[i] ^ iv[i] );            memcpy( iv, temp, 16 );            input  += 16;            output += 16;            length -= 16;        }    }}int main(){    unsigned char key[16] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};    unsigned char input[16] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};    unsigned char output[16];    sm4_context ctx;    unsigned long i;    //encrypt standard testing vector    // sm4_setkey_enc(&amp;ctx,key);    // sm4_crypt_ecb(&amp;ctx,1,16,input,output);    // for(i=0;i&lt;16;i++)    //     printf(\"%02x \", output[i]);    // printf(\"\\n\");    //decrypt testing    // sm4_setkey_dec(&amp;ctx,key);    // sm4_crypt_ecb(&amp;ctx,0,16,output,output);    // for(i=0;i&lt;16;i++)    //     printf(\"%02x \", output[i]);    // printf(\"\\n\");    //decrypt 1M times testing vector based on standards.        #include &lt;time.h&gt;    time_t c_start, c_end;      c_start = clock();    i = 0;    sm4_setkey_enc(&amp;ctx,key);    while (i&lt;1000000)     {        sm4_crypt_ecb(&amp;ctx,1,16,input,input);        i++;    }    for(i=0;i&lt;16;i++)        printf(\"%02x \", input[i]);    printf(\"\\n\");    c_end   = clock();    printf(\"run 1000000 times  used %f ms \\n\",difftime(c_end,c_start));        return 0;}\n\n\n\nDES标志位修改一下就行了，加解密同源，实际上就是把 sub_key 倒过来\n代码1#include&lt;stdio.h&gt;  #include&lt;string.h&gt; #include&lt;stdlib.h&gt; #include\"table.h\"//存储各种数据表的头文件 // 十六轮子密钥 static bool SubKey[16][48] = { 0 }; /*-----------------------------自定义函数-----------------------------*/ void SetKey(char My_key[8]); //生成16轮的子密钥  void ByteToBit(bool * Data_out, char * Data_in, int Num); //字节转换成位 void BitToByte(char My_message[8], bool * Message_in, int Num); //位转换成字节  void TableReplace(bool *Data_out, bool *Data_in, const char *Table, int Num);  //各种表的置换算法  void Bitcopy(bool * Data_out, bool * Data_in, int Num);  //二进制数组的拷贝  void Loop_bit(bool * Data_out, int movstep, int len);  //左移 void Run_Des(char My_message[8], char CIPhertext[64]);//des的轮加密算法 void Xor(bool * Message_out, bool * Message_in, int Num); //执行异或  void S_change(bool * Data_out, bool * Data_in);  // S盒变换  void Run_desDes(char My_message[8], char CIPhertext[64]);// DES轮解密算法 /*--------------------------*//*--------------------------主函数----------------------------------*/int main(){    \tint i = 0, j;    \tchar My_key[8] = { 0 };  //记录加密密钥    \tchar You_key[8] = { 0 }; //解密密钥    \tchar My_message[8] = { 0 }; //明文    \tchar CIPhertext[64] = { 0 };//密文    \tprintf(\"请输入你要加密的内容(8 Byte):\\n\");    \tscanf(\"%s\", My_message);    \tprintf(\"请输入你的加密密钥(8 Byte):\\n\");    \tscanf(\"%s\", My_key);    \ti = strlen(My_key);    \twhile (i != 8)//确保密钥长度为8byte    \t{      \t    printf(\"请输入加密密钥(8 Byte)\\n\");      \t    scanf(\"%s\", My_key);      \t    i = 0;       \t    i = strlen(My_key);   \t}    \tSetKey(My_key);  //生成16轮的加密子密钥  \tRun_Des(My_message, CIPhertext); //des的轮加密过程   \tprintf(\"经过加密的密文为(二进制):\\n\");    \tprintf(\"%s\", CIPhertext);    \tprintf(\"\\n\");    \tRun_desDes(My_message, CIPhertext);//解密;    \tprintf(\"解密结果为:\\n\");    \tprintf(\"%s\", My_message);    \tprintf(\"\\n\");\treturn 0; } /*--------------------具体函数定义----------------------*/ void Bitcopy(bool * Data_out, bool * Data_in, int Num) //二进制数组拷贝 {    \tint i = 0;    \tfor (i = 0; i &lt; Num; i++)       \tData_out[i] = Data_in[i]; } void ByteToBit(bool * Data_out, char * Data_in, int Num) //字节转位，num为二进制位数 {    \tint i, j;    \tfor (i = 0; i &lt; Num; i++)       \tData_out[i] = (Data_in[i / 8] &gt;&gt; (i % 8)) &amp; 0x01; }void BitToByte(char My_message[8], bool * Message_in, int Num) //位转换成字节，num为位数 {    \tint i = 0;    \tfor (i = 0; i &lt; (Num / 8); i++)    \t\tMy_message[i] = 0;\tfor (i = 0; i &lt; Num; i++)   \t\tMy_message[i / 8] |= Message_in[i] &lt;&lt; (i % 8);} void TableReplace(bool *Data_out, bool * Data_in, const char *Table, int Num) // 置换算法,Num表示置换表的长度 {    \tint i = 0;    \tstatic bool Temp[256] = { 0 };    \tfor (i = 0; i &lt; Num; i++)    \t{       \t Temp[i] = Data_in[Table[i] - 1];//将输入数据的指定位置作为输出数据的第i位    \t }    \t Bitcopy(Data_out, Temp, Num);}void Loop_bit(bool * Data_out, int movstep, int len)//左循环移位 {   \t static bool Temp[256] = { 0 };   \t Bitcopy(Temp, Data_out, movstep);//将前movstep位数据放入temp缓存   \t Bitcopy(Data_out, Data_out + movstep, len - movstep);//数据依次向左移位    \t Bitcopy(Data_out + len - movstep, Temp, movstep);//将temp中缓存的数据放入最后 } void Xor(bool * Message_out, bool * Message_in, int Num)//执行异或 {    \tint i;\tfor (i = 0; i &lt; Num; i++)    \t{       \t Message_out[i] = Message_out[i] ^ Message_in[i];   \t} } void SetKey(char My_key[8])//8字节的初始密钥 {    \tint i, j;    \tstatic bool Key_bit[64] = { 0 }; //Key的二进制缓存    \tstatic bool *Key_bit_L, *Key_bit_R;    \tKey_bit_L = &amp;Key_bit[0]; //key的左边28位    \tKey_bit_R = &amp;Key_bit[28]; //key的右边28位  \tByteToBit(Key_bit, My_key, 64);    \tTableReplace(Key_bit, Key_bit, PC1_Table, 56);//pc-1 置换    \tfor (i = 0; i &lt; 16; i++)//生成第i个子密钥Subkey[i]  \t{        \t\tLoop_bit(Key_bit_L, Move_Table[i], 28);//左边28位进行左循环移位        \t\tLoop_bit(Key_bit_R, Move_Table[i], 28);//右边28位进行左循环移位        \t\tTableReplace(SubKey[i], Key_bit, PC2_Table, 48);//pc-2置换    \t} } void S_change(bool * Data_out, bool * Data_in) //S盒变换 {    \tint i;    \tint r = 0, c = 0;//S盒的行和列    \tfor (i = 0; i &lt; 8; i++, Data_in = Data_in + 6, Data_out = Data_out + 4) // 每6bit输入进行一次代换    \t{        \t\tr = Data_in[0] * 2 + Data_in[5] * 1;//将m1m6转换为十进制数，作为行数        \t\tc = Data_in[1] * 8 + Data_in[2] * 4 + Data_in[3] * 2 + Data_in[4] * 1;//将m2m3m4m5转换为十进制数，作为列数        \t\t\tByteToBit(Data_out, &amp;S_Box[i][r][c], 4);//取S盒数据,将其二进制形式的每一位填到输出的指定位置    \t} } void F_change(bool Data_out[32], bool Data_in[48])   // f函数 {    \tint i;    \tstatic bool Message_E[48] = { 0 };  //存放E置换的结果    \tTableReplace(Message_E, Data_out, E_Table, 48);//E表置换    \tXor(Message_E, Data_in, 48);//与密钥K[i]异或    \tS_change(Data_out, Message_E);  // S盒变换    \tTableReplace(Data_out, Data_out, P_Table, 32);  //P置换 }void Run_Des(char My_message[8], char CIPhertext[64])//des轮加密算法 {    \tint i;    \tstatic bool Message_bit[64] = { 0 };    \tstatic bool *Message_bit_L = &amp;Message_bit[0], *Message_bit_R = &amp;Message_bit[32];//分成左右两部分，每部分32位    \tstatic bool Temp[32] = { 0 };    \tByteToBit(Message_bit, My_message, 64);    \t\t\tTableReplace(Message_bit, Message_bit, IP_Table, 64);//初始置换    \tfor (i = 0; i &lt; 16; i++)//每一轮的加密    \t{        \t\tBitcopy(Temp, Message_bit_R, 32);//缓存右32位        \t\tF_change(Message_bit_R, SubKey[i]);//轮函数F        \t\tXor(Message_bit_R, Message_bit_L, 32);//左32位与轮函数F输出进行异或        \t\tBitcopy(Message_bit_L, Temp, 32);//右32位R(i-1)作为下一轮的Li    \t}    \tTableReplace(Message_bit, Message_bit, IPR_Table, 64);//逆初始置换    \tfor (i = 0; i &lt; 64;i++)        \tCIPhertext[i] = Message_bit[i]+'0';//由于是将bool型数据赋给字符型数据，因此要+'0'    \tCIPhertext[i] = '\\0'; } void Run_desDes(char My_message[8], char CIPhertext[64])// DES轮解密算法 {    \tint i = 0;    \tstatic bool Message_bit[64] = { 0 };    \tstatic bool * Message_bit_L = &amp;Message_bit[0], *Message_bit_R = &amp;Message_bit[32];    \tstatic bool Temp[32] = { 0 };    \tfor (i = 0; i &lt; 64; i++)        \tMessage_bit[i] = CIPhertext[i]-'0';    \tTableReplace(Message_bit, Message_bit, IP_Table, 64);    \tfor (i = 15; i &gt;= 0; i--)//与加密过程的区别是子密钥使用顺序相反    \t{        \t\tBitcopy(Temp, Message_bit_L, 32);        \t\tF_change(Message_bit_L, SubKey[i]);        \t\tXor(Message_bit_L, Message_bit_R, 32);\t\t\tBitcopy(Message_bit_R, Temp, 32);    }    \t\t\t\t\tTableReplace(Message_bit, Message_bit, IPR_Table, 64);    \t\tBitToByte(My_message, Message_bit, 64); \t}}\n\n代码2/* * Data Encryption Standard * An approach to DES algorithm *  * By: Daniel Huertas Gonzalez * Email: huertas.dani@gmail.com * Version: 0.1 *  * Based on the document FIPS PUB 46-3 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define LB32_MASK   0x00000001#define LB64_MASK   0x0000000000000001#define L64_MASK    0x00000000ffffffff#define H64_MASK    0xffffffff00000000/* Initial Permutation Table */static char IP[] = {    58, 50, 42, 34, 26, 18, 10,  2,     60, 52, 44, 36, 28, 20, 12,  4,     62, 54, 46, 38, 30, 22, 14,  6,     64, 56, 48, 40, 32, 24, 16,  8,     57, 49, 41, 33, 25, 17,  9,  1,     59, 51, 43, 35, 27, 19, 11,  3,     61, 53, 45, 37, 29, 21, 13,  5,     63, 55, 47, 39, 31, 23, 15,  7};/* Inverse Initial Permutation Table */static char PI[] = {    40,  8, 48, 16, 56, 24, 64, 32,     39,  7, 47, 15, 55, 23, 63, 31,     38,  6, 46, 14, 54, 22, 62, 30,     37,  5, 45, 13, 53, 21, 61, 29,     36,  4, 44, 12, 52, 20, 60, 28,     35,  3, 43, 11, 51, 19, 59, 27,     34,  2, 42, 10, 50, 18, 58, 26,     33,  1, 41,  9, 49, 17, 57, 25};/*Expansion table */static char E[] = {    32,  1,  2,  3,  4,  5,       4,  5,  6,  7,  8,  9,       8,  9, 10, 11, 12, 13,     12, 13, 14, 15, 16, 17,     16, 17, 18, 19, 20, 21,     20, 21, 22, 23, 24, 25,     24, 25, 26, 27, 28, 29,     28, 29, 30, 31, 32,  1};/* Post S-Box permutation */static char P[] = {    16,  7, 20, 21,     29, 12, 28, 17,      1, 15, 23, 26,      5, 18, 31, 10,      2,  8, 24, 14,     32, 27,  3,  9,     19, 13, 30,  6,     22, 11,  4, 25};/* The S-Box tables */static char S[8][64] = {{    /* S1 */    14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,       0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,       4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,     15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13},{    /* S2 */    15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,       3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,       0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,     13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9},{    /* S3 */    10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,      13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,      13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,     1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12},{    /* S4 */     7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,      13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,      10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,     3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14},{    /* S5 */     2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,     14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,      4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,     11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3},{    /* S6 */    12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,    10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,     9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,     4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13},{    /* S7 */     4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,    13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,     1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,     6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12},{    /* S8 */    13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,     1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,     7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,     2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11}};/* Permuted Choice 1 Table */static char PC1[] = {    57, 49, 41, 33, 25, 17,  9,     1, 58, 50, 42, 34, 26, 18,    10,  2, 59, 51, 43, 35, 27,    19, 11,  3, 60, 52, 44, 36,        63, 55, 47, 39, 31, 23, 15,     7, 62, 54, 46, 38, 30, 22,    14,  6, 61, 53, 45, 37, 29,    21, 13,  5, 28, 20, 12,  4};/* Permuted Choice 2 Table */static char PC2[] = {    14, 17, 11, 24,  1,  5,     3, 28, 15,  6, 21, 10,    23, 19, 12,  4, 26,  8,    16,  7, 27, 20, 13,  2,    41, 52, 31, 37, 47, 55,    30, 40, 51, 45, 33, 48,    44, 49, 39, 56, 34, 53,    46, 42, 50, 36, 29, 32};/* Iteration Shift Array */static char iteration_shift[] = { /* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */    1,  1,  2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  1};/* * The DES function * input: 64 bit message * key: 64 bit key for encryption/decryption * mode: 'e' = encryption; 'd' = decryption */uint64_t des(uint64_t input, uint64_t key, char mode) {        int i, j;        /* 8 bits */    char row, column;        /* 28 bits */    uint32_t C                  = 0;    uint32_t D                  = 0;        /* 32 bits */    uint32_t L                  = 0;    uint32_t R                  = 0;    uint32_t s_output           = 0;    uint32_t f_function_res     = 0;    uint32_t temp               = 0;        /* 48 bits */    uint64_t sub_key[16]        = {0};    uint64_t s_input            = 0;        /* 56 bits */    uint64_t permuted_choice_1  = 0;    uint64_t permuted_choice_2  = 0;        /* 64 bits */    uint64_t init_perm_res      = 0;    uint64_t inv_init_perm_res  = 0;    uint64_t pre_output         = 0;        /* initial permutation */    for (i = 0; i &lt; 64; i++) {                init_perm_res &lt;&lt;= 1;        init_perm_res |= (input &gt;&gt; (64-IP[i])) &amp; LB64_MASK;            }        L = (uint32_t) (init_perm_res &gt;&gt; 32) &amp; L64_MASK;    R = (uint32_t) init_perm_res &amp; L64_MASK;            /* initial key schedule calculation */    for (i = 0; i &lt; 56; i++) {                permuted_choice_1 &lt;&lt;= 1;        permuted_choice_1 |= (key &gt;&gt; (64-PC1[i])) &amp; LB64_MASK;    }        C = (uint32_t) ((permuted_choice_1 &gt;&gt; 28) &amp; 0x000000000fffffff);    D = (uint32_t) (permuted_choice_1 &amp; 0x000000000fffffff);        /* Calculation of the 16 keys */    for (i = 0; i&lt; 16; i++) {                /* key schedule */        // shifting Ci and Di        for (j = 0; j &lt; iteration_shift[i]; j++) {                        C = 0x0fffffff &amp; (C &lt;&lt; 1) | 0x00000001 &amp; (C &gt;&gt; 27);            D = 0x0fffffff &amp; (D &lt;&lt; 1) | 0x00000001 &amp; (D &gt;&gt; 27);                    }                permuted_choice_2 = 0;        permuted_choice_2 = (((uint64_t) C) &lt;&lt; 28) | (uint64_t) D ;                sub_key[i] = 0;                for (j = 0; j &lt; 48; j++) {                        sub_key[i] &lt;&lt;= 1;            sub_key[i] |= (permuted_choice_2 &gt;&gt; (56-PC2[j])) &amp; LB64_MASK;                    }            }        for (i = 0; i &lt; 16; i++) {                /* f(R,k) function */        s_input = 0;                for (j = 0; j&lt; 48; j++) {                        s_input &lt;&lt;= 1;            s_input |= (uint64_t) ((R &gt;&gt; (32-E[j])) &amp; LB32_MASK);                    }                /*          * Encryption/Decryption          * XORing expanded Ri with Ki         */        if (mode == 'd') {            // decryption            s_input = s_input ^ sub_key[15-i];                    } else {            // encryption            s_input = s_input ^ sub_key[i];                    }                /* S-Box Tables */        for (j = 0; j &lt; 8; j++) {            // 00 00 RCCC CR00 00 00 00 00 00 s_input            // 00 00 1000 0100 00 00 00 00 00 row mask            // 00 00 0111 1000 00 00 00 00 00 column mask                        row = (char) ((s_input &amp; (0x0000840000000000 &gt;&gt; 6*j)) &gt;&gt; 42-6*j);            row = (row &gt;&gt; 4) | row &amp; 0x01;                        column = (char) ((s_input &amp; (0x0000780000000000 &gt;&gt; 6*j)) &gt;&gt; 43-6*j);                        s_output &lt;&lt;= 4;            s_output |= (uint32_t) (S[j][16*row + column] &amp; 0x0f);                    }                f_function_res = 0;                for (j = 0; j &lt; 32; j++) {                        f_function_res &lt;&lt;= 1;            f_function_res |= (s_output &gt;&gt; (32 - P[j])) &amp; LB32_MASK;                    }                temp = R;        R = L ^ f_function_res;        L = temp;            }        pre_output = (((uint64_t) R) &lt;&lt; 32) | (uint64_t) L;            /* inverse initial permutation */    for (i = 0; i &lt; 64; i++) {                inv_init_perm_res &lt;&lt;= 1;        inv_init_perm_res |= (pre_output &gt;&gt; (64-PI[i])) &amp; LB64_MASK;            }        return inv_init_perm_res;    }int main(int argc, const char * argv[]) {    int i;        uint64_t input = 0x9474B8E8C73BCA7D;    uint64_t key = 0x0000000000000000;    uint64_t result = input;        /*     * TESTING IMPLEMENTATION OF DES     * Ronald L. Rivest      * X0:  9474B8E8C73BCA7D     * X16: 1B1A2DDB4C642438     *     * OUTPUT:     * E: 8da744e0c94e5e17     * D: 0cdb25e3ba3c6d79     * E: 4784c4ba5006081f     * D: 1cf1fc126f2ef842     * E: e4be250042098d13     * D: 7bfc5dc6adb5797c     * E: 1ab3b4d82082fb28     * D: c1576a14de707097     * E: 739b68cd2e26782a     * D: 2a59f0c464506edb     * E: a5c39d4251f0a81e     * D: 7239ac9a6107ddb1     * E: 070cac8590241233     * D: 78f87b6e3dfecf61     * E: 95ec2578c2c433f0     * D: 1b1a2ddb4c642438  &lt;-- X16     */    for (i = 0; i &lt; 16; i++) {                if (i%2 == 0) {                        result = des(result, result, 'e');            printf (\"E: %016llx\\n\", result);                    } else {                        result = des(result, result, 'd');            printf (\"D: %016llx\\n\", result);                    }    }        //result = des(input, key, 'e');    //printf (\"E: %016llx\\n\", result);        //result = des(result, key, 'd');    //printf (\"D: %016llx\\n\", result);        exit(0);    }\n\n\n\nBASE58#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; unsigned char* en_base58(unsigned char* input)  // 编码{    static char* nb58 = (char*)\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";    size_t len = strlen((char*)input);    size_t rlen = (len / 2 + 1) * 3;    unsigned char* ret = (unsigned char*)malloc(rlen + len);    unsigned char* src = ret + rlen;    unsigned char* rptr = ret + rlen;    unsigned char* ptr, * e = src + len - 1;    size_t i;    memcpy(src, input, len);    while (src &lt;= e)    {        if (*src)        {            unsigned char rest = 0;            ptr = src;            while (ptr &lt;= e)            {                unsigned int c = rest * 256;                rest = (c + *ptr) % 58;                *ptr = (c + *ptr) / 58;                ptr++;            }            --rptr;            *rptr = nb58[rest];        }        else        {            src++;        }    }    for (i = 0; i &lt; ret + rlen - rptr; i++)        ret[i] = rptr[i];    ret[i] = 0;    return ret;} bool de_base58(unsigned char* src)  // 解码{    static char b58n[] =    {        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1,  0,  1,  2,  3,  4,  5,  6,  7,  8, -1, -1, -1, -1, -1, -1,        -1,  9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1,        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1,        -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46,        47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    };    size_t len = strlen((char*)src);    size_t rlen = (len / 4 + 1) * 3;    unsigned char* ret = (unsigned char*)malloc(rlen);    unsigned char* rptr = ret + rlen;    size_t i;    unsigned char* ptr;    for (i = 0; i &lt; len; i++)    {        char rest = b58n[src[i]];        if (rest &lt; 0)        {            free(ret);            return NULL;        }        for (ptr = ret + rlen - 1; ptr &gt;= rptr; ptr--)        {            unsigned int c = rest + *ptr * 58;            *ptr = c % 256;            rest = c / 256;        }        if (rest &gt; 0)        {            rptr--;            if (rptr &lt; ret)            {                free(ret);                return NULL;            }            *rptr = rest;        }    }    for (i = 0; i &lt; ret + rlen - rptr; i++)        ret[i] = rptr[i];    ret[i] = 0;    memcpy(src, ret, strlen((char*)src));} int main(){    char str[] = \"9EGJCxbxRGT\";    printf(\"%s\\n\", en_base58((unsigned char*)\"12345678\"));    de_base58((unsigned char*)str);    printf(\"%s\", str);    getchar();    return 0;}\n\nSHA1#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt; #define rol(x,y) ((x&lt;&lt;y)|(x&gt;&gt;(32-y)))  //循环左移 //一次循环过程，str为填充后的数据或是数据中的一部分 void round(unsigned char str[64],unsigned int h[5]){\tunsigned int a, b, c, d, e,tmp,w[80];\tunsigned int i;\tfor(i=0;i&lt;16;i++){\t\tw[i]=((unsigned int)str[i*4]&lt;&lt;24)|(((unsigned int)str[i*4+1])&lt;&lt;16)|\t\t\t\t\t\t(((unsigned int)str[i*4+2])&lt;&lt;8)|(((unsigned int)str[i*4+3])&lt;&lt;0);\t}\tfor (i=16;i&lt;80;i++ ){\t\ttmp = w[i-3]^w[i-8]^w[i-14]^w[i-16];\t\tw[i]=rol(tmp,1);    }        a=h[0];b=h[1];c=h[2];d=h[3];e=h[4];    for(i=0;i&lt;80;i++){    \tswitch(i/20){    \t\tcase 0:tmp=rol(a,5)+((b&amp;c)|(d&amp;~b))+e+w[i]+0x5a827999;break;    \t\tcase 1:tmp=rol(a,5)+(b^c^d)+e+w[i]+0x6ed9eba1;break;    \t\tcase 2:tmp=rol(a,5)+((b&amp;c)|(b&amp;d)|(c&amp;d))+e+w[i] +0x8f1bbcdc;break;    \t\tcase 3:tmp=rol(a,5)+(b^c^d)+e+w[i] + 0xca62c1d6;break;\t\t}\t\te=d;d=c;\t\tc=rol(b,30);\t\tb=a;a=tmp;\t}\th[0]+=a;h[1]+=b;h[2]+=c;h[3]+=d;h[4]+=e;}//sha-1算法 void sha1(unsigned char*input,long long len,unsigned char*output){\tunsigned char temp[64];\tunsigned int h[5]={0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0};\tunsigned int i,n=len,tmp;\twhile(n&gt;=64){\t\tmemcpy(temp,input+len-n,64);\t\tround(temp,h);\t\tn-=64;\t}\t\tif(n&gt;=56){\t\tmemset(temp,0,64);\t\tmemcpy(temp,input+len-n,n);temp[n]=128;\t\tround(temp,h);\t\tmemset(temp,0,64);\t\tfor(i=56;i&lt;64;i++)\t\t\ttemp[i]=((len*8)&gt;&gt;(63-i)*8)&amp;0xff;\t\tround(temp,h);\t}\telse{\t\tmemset(temp,0,64);\t\tmemcpy(temp,input+len-n,n);temp[n]=128;\t\tfor(i=56;i&lt;64;i++)\t\t\ttemp[i]=((len*8)&gt;&gt;(63-i)*8)&amp;0xff;\t\tround(temp,h);\t\t}\t\tfor(i=0;i&lt;20;i++){\t\ttmp=(h[i/4]&gt;&gt;((3-i%4)*8))&amp;0xff;\t\tsprintf((char*)output+2*i,\"%02x\",tmp);\t}}//测试 int main(){\tunsigned char input[]=\"this is a test aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",output[40]={0};\tsha1(input,strlen((char*)input),output);\tprintf(\"%s\\n\",output);}\n\nCRC32/* crc32.c   Copyright (C) 2009-2024 Free Software Foundation, Inc.   This file is part of the libiberty library.   This file is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2 of the License, or   (at your option) any later version.   In addition to the permissions in the GNU General Public License, the   Free Software Foundation gives you unlimited permission to link the   compiled version of this file into combinations with other programs,   and to distribute those combinations without any restriction coming   from the use of this file.  (The General Public License restrictions   do apply in other respects; for example, they cover modification of   the file, and distribution when not linked into a combined   executable.)   This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.   You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.*/#ifdef HAVE_CONFIG_H#include \"config.h\"#endif#include \"libiberty.h\"/* This table was generated by the following program.   #include &lt;stdio.h&gt;   int   main ()   {     unsigned int i, j;     unsigned int c;     int table[256];     for (i = 0; i &lt; 256; i++)       {\t for (c = i &lt;&lt; 24, j = 8; j &gt; 0; --j)\t   c = c &amp; 0x80000000 ? (c &lt;&lt; 1) ^ 0x04c11db7 : (c &lt;&lt; 1);\t table[i] = c;       }     printf (\"static const unsigned int crc32_table[] =\\n{\\n\");     for (i = 0; i &lt; 256; i += 4)       {\t printf (\"  0x%08x, 0x%08x, 0x%08x, 0x%08x\",\t\t table[i + 0], table[i + 1], table[i + 2], table[i + 3]);\t if (i + 4 &lt; 256)\t   putchar (',');\t putchar ('\\n');       }     printf (\"};\\n\");     return 0;   }   For more information on CRC, see, e.g.,   http://www.ross.net/crc/download/crc_v3.txt.  */static const unsigned int crc32_table[] ={  0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,  0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,  0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,  0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,  0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,  0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,  0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,  0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,  0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,  0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,  0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,  0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,  0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,  0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,  0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,  0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,  0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,  0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,  0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,  0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,  0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,  0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,  0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,  0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,  0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,  0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,  0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,  0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,  0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,  0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,  0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,  0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,  0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,  0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,  0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,  0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,  0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,  0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,  0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,  0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,  0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,  0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,  0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,  0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,  0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,  0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,  0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,  0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,  0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,  0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,  0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,  0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,  0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,  0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,  0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,  0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,  0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,  0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,  0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,  0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,  0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,  0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,  0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,  0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4};/*@deftypefn Extension {unsigned int} crc32 (const unsigned char *@var{buf}, @  int @var{len}, unsigned int @var{init})Compute the 32-bit CRC of @var{buf} which has length @var{len}.  Thestarting value is @var{init}; this may be used to compute the CRC ofdata split across multiple buffers by passing the return value of eachcall as the @var{init} parameter of the next.This is used by the @command{gdb} remote protocol for the @samp{qCRC}command.  In order to get the same results as gdb for a block of data,you must pass the first CRC parameter as @code{0xffffffff}.This CRC can be specified as:  Width  : 32  Poly   : 0x04c11db7  Init   : parameter, typically 0xffffffff  RefIn  : false  RefOut : false  XorOut : 0This differs from the \"standard\" CRC-32 algorithm in that the valuesare not reflected, and there is no final XOR value.  These differencesmake it easy to compose the values of multiple blocks.@end deftypefn*/unsigned intxcrc32 (const unsigned char *buf, int len, unsigned int init){  unsigned int crc = init;  while (len--)    {      crc = (crc &lt;&lt; 8) ^ crc32_table[((crc &gt;&gt; 24) ^ *buf) &amp; 255];      buf++;    }  return crc;}\n\nMD5/* * Derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm * and modified slightly to be functionally identical but condensed into control structures. */#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct{    uint64_t size;        // Size of input in bytes    uint32_t buffer[4];   // Current accumulation of hash    uint8_t input[64];    // Input to be used in the next step    uint8_t digest[16];   // Result of algorithm} MD5Context;/* * Constants defined by the MD5 algorithm */#define A 0x67452301#define B 0xefcdab89#define C 0x98badcfe#define D 0x10325476static uint32_t S[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,                       5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,                       4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,                       6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};static uint32_t K[] = {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,                       0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,                       0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,                       0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,                       0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,                       0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,                       0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,                       0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,                       0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,                       0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,                       0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,                       0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,                       0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,                       0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,                       0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,                       0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};/* * Padding used to make the size (in bits) of the input congruent to 448 mod 512 */static uint8_t PADDING[] = {0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};/* * Bit-manipulation functions defined by the MD5 algorithm */#define F(X, Y, Z) ((X &amp; Y) | (~X &amp; Z))#define G(X, Y, Z) ((X &amp; Z) | (Y &amp; ~Z))#define H(X, Y, Z) (X ^ Y ^ Z)#define I(X, Y, Z) (Y ^ (X | ~Z))/* * Rotates a 32-bit word left by n bits */uint32_t rotateLeft(uint32_t x, uint32_t n){    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n));}/* * Initialize a context */void md5Init(MD5Context *ctx){    ctx-&gt;size = (uint64_t)0;    ctx-&gt;buffer[0] = (uint32_t)A;    ctx-&gt;buffer[1] = (uint32_t)B;    ctx-&gt;buffer[2] = (uint32_t)C;    ctx-&gt;buffer[3] = (uint32_t)D;}/* * Add some amount of input to the context * * If the input fills out a block of 512 bits, apply the algorithm (md5Step) * and save the result in the buffer. Also updates the overall size. */void md5Update(MD5Context *ctx, uint8_t *input_buffer, size_t input_len){    uint32_t input[16];    unsigned int offset = ctx-&gt;size % 64;    ctx-&gt;size += (uint64_t)input_len;    // Copy each byte in input_buffer into the next space in our context input    for(unsigned int i = 0; i &lt; input_len; ++i){        ctx-&gt;input[offset++] = (uint8_t)*(input_buffer + i);        // If we've filled our context input, copy it into our local array input        // then reset the offset to 0 and fill in a new buffer.        // Every time we fill out a chunk, we run it through the algorithm        // to enable some back and forth between cpu and i/o        if(offset % 64 == 0){            for(unsigned int j = 0; j &lt; 16; ++j){                // Convert to little-endian                // The local variable `input` our 512-bit chunk separated into 32-bit words                // we can use in calculations                input[j] = (uint32_t)(ctx-&gt;input[(j * 4) + 3]) &lt;&lt; 24 |                           (uint32_t)(ctx-&gt;input[(j * 4) + 2]) &lt;&lt; 16 |                           (uint32_t)(ctx-&gt;input[(j * 4) + 1]) &lt;&lt;  8 |                           (uint32_t)(ctx-&gt;input[(j * 4)]);            }            md5Step(ctx-&gt;buffer, input);            offset = 0;        }    }}/* * Pad the current input to get to 448 bytes, append the size in bits to the very end, * and save the result of the final iteration into digest. */void md5Finalize(MD5Context *ctx){    uint32_t input[16];    unsigned int offset = ctx-&gt;size % 64;    unsigned int padding_length = offset &lt; 56 ? 56 - offset : (56 + 64) - offset;    // Fill in the padding and undo the changes to size that resulted from the update    md5Update(ctx, PADDING, padding_length);    ctx-&gt;size -= (uint64_t)padding_length;    // Do a final update (internal to this function)    // Last two 32-bit words are the two halves of the size (converted from bytes to bits)    for(unsigned int j = 0; j &lt; 14; ++j){        input[j] = (uint32_t)(ctx-&gt;input[(j * 4) + 3]) &lt;&lt; 24 |                   (uint32_t)(ctx-&gt;input[(j * 4) + 2]) &lt;&lt; 16 |                   (uint32_t)(ctx-&gt;input[(j * 4) + 1]) &lt;&lt;  8 |                   (uint32_t)(ctx-&gt;input[(j * 4)]);    }    input[14] = (uint32_t)(ctx-&gt;size * 8);    input[15] = (uint32_t)((ctx-&gt;size * 8) &gt;&gt; 32);    md5Step(ctx-&gt;buffer, input);    // Move the result into digest (convert from little-endian)    for(unsigned int i = 0; i &lt; 4; ++i){        ctx-&gt;digest[(i * 4) + 0] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x000000FF));        ctx-&gt;digest[(i * 4) + 1] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x0000FF00) &gt;&gt;  8);        ctx-&gt;digest[(i * 4) + 2] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0x00FF0000) &gt;&gt; 16);        ctx-&gt;digest[(i * 4) + 3] = (uint8_t)((ctx-&gt;buffer[i] &amp; 0xFF000000) &gt;&gt; 24);    }}/* * Step on 512 bits of input with the main MD5 algorithm. */void md5Step(uint32_t *buffer, uint32_t *input){    uint32_t AA = buffer[0];    uint32_t BB = buffer[1];    uint32_t CC = buffer[2];    uint32_t DD = buffer[3];    uint32_t E;    unsigned int j;    for(unsigned int i = 0; i &lt; 64; ++i){        switch(i / 16){            case 0:                E = F(BB, CC, DD);                j = i;                break;            case 1:                E = G(BB, CC, DD);                j = ((i * 5) + 1) % 16;                break;            case 2:                E = H(BB, CC, DD);                j = ((i * 3) + 5) % 16;                break;            default:                E = I(BB, CC, DD);                j = (i * 7) % 16;                break;        }        uint32_t temp = DD;        DD = CC;        CC = BB;        BB = BB + rotateLeft(AA + E + K[i] + input[j], S[i]);        AA = temp;    }    buffer[0] += AA;    buffer[1] += BB;    buffer[2] += CC;    buffer[3] += DD;}/* * Functions that run the algorithm on the provided input and put the digest into result. * result should be able to store 16 bytes. */void md5String(char *input, uint8_t *result){    MD5Context ctx;    md5Init(&amp;ctx);    md5Update(&amp;ctx, (uint8_t *)input, strlen(input));    md5Finalize(&amp;ctx);    memcpy(result, ctx.digest, 16);}void md5File(FILE *file, uint8_t *result){    char *input_buffer = malloc(1024);    size_t input_size = 0;    MD5Context ctx;    md5Init(&amp;ctx);    while((input_size = fread(input_buffer, 1, 1024, file)) &gt; 0){        md5Update(&amp;ctx, (uint8_t *)input_buffer, input_size);    }    md5Finalize(&amp;ctx);    free(input_buffer);    memcpy(result, ctx.digest, 16);}void print_hash(uint8_t *p){    for(unsigned int i = 0; i &lt; 16; ++i){        printf(\"%02x\", p[i]);    }    printf(\"\\n\");}int main(int argc, char *argv[]){    uint8_t result[16];    if(argc &gt; 1){        for(int i = 1; i &lt; argc; ++i){            md5String(argv[i], result);            print_hash(result);        }    } else{        md5File(stdin, result);        print_hash(result);    }}\n\nRC4#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt;//s表的长度取256#define size 256unsigned char sbox[257]={0};//初始化s表void init_sbox(unsigned char*key){\tunsigned int i,j,k;\tint tmp;\t\tfor(i=0;i&lt;size;i++){\t\tsbox[i]=i;\t}\t\tj=k=0;\tfor(i=0;i&lt;size;i++){\t\ttmp=sbox[i];\t\tj=(j+tmp+key[k])%size;\t\tsbox[i]=sbox[j];\t\tsbox[j]=tmp;\t\tif(++k&gt;=strlen((char*)key))k=0;\t}}//加解密函数void enc_dec(unsigned char*key,unsigned char*data){\tint i,j,k,R,tmp;\t\tinit_sbox(key);\t\tj=k=0;\t\tfor(i=0;i&lt;strlen((char*)data);i++){\t\tj=(j+1)%size;\t\tk=(k+sbox[j])%size;\t\t\t\ttmp=sbox[j];\t\tsbox[j]=sbox[k];\t\tsbox[k]=tmp;\t\t\t\tR=sbox[(sbox[j]+sbox[k])%size];\t\t\t\tdata[i]^=R;\t}\t}int main(){\tunsigned char key[100]={0};\tunsigned char data[100]={0};\tprintf(\"输入你要加密的字符：\");\tscanf(\"%100s\",data);\tprintf(\"输入密钥：\");\tscanf(\"%40s\",key);\tenc_dec(key,data);\tprintf(\"enc: %s\\n\",data);\tenc_dec(key,data);\tprintf(\"dec: %s\\n\",data);\treturn 0;}\n\n参考链接Pangbai.work [常见加密解密算法]\nmengsuenyan [AES加密算法]\n枫のBlog 密码学——AES/DES加密算法原理介绍\ngcc-mirror c3c\nZunawe MD5\nwindard SM4\ndhuertas DES\nlmshao AES\n侵权请联系删除\n","tags":["Reverse","Encryption"]}]